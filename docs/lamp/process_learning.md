# 进程学习笔记

## 进程与程序
  程序是完成特定任务的一系列指令集合。
  
  什么是进程呢?
  * 从用户角度来看进程是程序的依次动态执行过程。
  * 从操作系统的核心来看，进程是操作系统分配的内存、CPU时间片等资源的基本单位。
  * 进程是资源分配的最小单位。
  * 每一个进程都有自己独立的地址空间与执行状态。
  * 像UNIX这样的多任务操作系统能够让许多程序同时运行，每一个运行着的程序就构成了一个进程。

  进程的数据结构
  
  进程的静态描述: 由三部分组成PCB(进程控制块)、有关程序段和该程序段对其进行操作的数据结构集。
  * 进程控制块(PCB): 用于描述进程情况及控制进程运行所需的全部信息，是操作系统用来感知进程存在的一个重要数据结构。
  * 代码段: 是进程中能被进程调度程序在CPU上执行的程序代码段。
  * 数据段: 一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行后产生的中间或最终数据。
  
  进程 = 代码段(编译后形成的一些指令) + 数据段(程序运行时需要的数据) + 堆栈段(程序运行时动态分配的一些内存) + PCB(进程信息，状态标识等)

  数据段包括:
  * 只读数据段: 常量
  * 已初始化数据段: 全局变量，静态变量
  * 未初始化数据段(bss)(0初始化段): 未初始化的全局变量和静态变量(实际上不分配内存，因为都为0，只有一些标记信息)

  进程与程序的区别和联系
  * 进程是动态的，程序是静态的。
  * 进程的生命周期是相对短暂的，而程序是永远的。
  * 进程数据结构PCB
  * 一个进程只能对应一个程序，一个程序可以对应多个进程

## 进程生命周期与PCB(进程控制块)

### 一. 进程状态变迁
  进程的三种基本状态:
  * Ready(就绪状态): 当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。
  * Running(执行状态): 当进程获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。
  * Blocked(阻塞状态): 正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可以由多种，例如，等待I/O的完成、申请缓冲区不能满足、等待信件(信号)等。

```
+------+        +----------+              +--------+              +--------+
|      |        |          |              |        |              |        |
| 新建 |------> |   就绪   | <--时间片到--|  运行  | -----------> |  结束  |
|      |        |          | ----调度---->|        |              |        |
+------+        +----------+              +--------+              +--------+
_                    ^                         |
_                    |                         |
_                I/O |                         | 等待某事件
_                结束|                         | 如I/O请求
_                    |     +--------+          |
_                    |     |        |          |
_                    +-----|  阻塞  |<---------+
_                          |        |
_                          +--------+
```
  一个进程在运行期间，不断从一个状态转换到另一种状态，它可以多次处于就绪和执行状态，也可以多次处于阻塞状态。
  * 就绪->执行: 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变为执行状态。
  * 执行->就绪: 处于执行状态的进程在执行过程中， 因为分配给它的一个时间片已经用完或更高优先级的进程抢占而不得不让出处理机，于是进程从执行状态转变成就绪状态。
  * 执行->阻塞: 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。
  * 阻塞->就绪: 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态变为就绪状态。
  * 运行->终止: 程序执行完毕，撤销而终止。
  
  
  以上时最经典也是最基本的三种进程状态，但现在的操作系统都根据需要重新涉及了一些新的状态。
  如linux:
  * 运行状态(TASK_RUNNING): 是运行态和就绪态的合并，表示进程正在运行或准备运行，Linux中使用TASK_RUNNING宏表示此状态。
  * 可中断睡眠状态(TASK_INTERRUPTIBLE): 进程正在睡眠(被阻塞)，等待资源的到来时唤醒，也可以通过其他进程信号或时钟中断唤醒，进入运行队列。Linux中使用TASK_INTERRUPTIBLE来表示此状态。
  * 不可中断睡眠状态(深度睡眠状态)TASK_UNINTERRUBPTIBLE: 和浅度睡眠基本类似，但有一点就是不可被其他进程信号或时钟中断唤醒。Linux使用TASK_UNINTERRUPTIBLE宏来表示此状态。
  * 暂停状态(TASK_STOPPED): 进程暂停执行接受某种处理。如正在接受调试的进程处于这种状态。
  * 僵死状态(TASK_ZOMBIE): 进程已经结束但未释放PCB

## 进程控制块(PCB)
  进程控制块包括:
  * 进程描述信息:
  <ul><li>进程标识符用于唯一标识一个进程(pid, ppid)</li></ul>
  * 进程控制信息:
  <ul>
    <li>进程当前状态</li>
    <li>进程优先级</li>
    <li>程序开始地址</li>
    <li>各种计时信息</li>
    <li>通信信息</li>
  </ul>
  * 资源信息:
  <ul>
    <li>占用内存大小及管理用数据结构指针</li>
    <li>交换区相关信息</li>
    <li>I/O设备号、缓冲、设备相关的数据结构</li>
    <li>文件系统相关指针</li>
  </ul>
  * 现场保护信息(cpu进行进程切换时):
  <ul>
    <li>寄存器</li>
    <li>PC</li>
    <li>程序状态字PSW</li>
    <li>栈指针</li>
  </ul>

  进程标识:PID
  每个进程都会分配到一个独一无二的数字编号，我们称之为进程标识，或者就叫做PID.是正整数，取值范围从2到32768.
  可以通过cat /proc/sys/kernel/pid_max查看系统支持多少进程
  
  当一个进程被启动，它会顺序挑选下一个未使用的编号数字作为自己的PID.
  数字1一般未特殊进程init保留的。 init进程实际上是用户进程，它是一个程序，在/sbin/init, linux启动的第一个进程。
  实际上linux中还存在0号进程(内核进程), 它是一个空闲进程，它进行空闲资源的统计及交换空间的换入换出，1(init)进程是从0号进程创建的。
  
## 三. 进程创建
  不同操作系统所提供的进程创建原语的名称和格式不尽相同，但执行创建进程原语后，操作系统所做的工作却大致相同， 都包括以下几点:
  * 给新创建的进程分配一个内部标识(pcb), 在内核中建立进程结构。
  * 复制父进程的环境。
  * 为进程分配资源，包括进程映像所需要的所有元素(程序、数据、用户栈等)
  * 复制父进程地址空间的内容到该进程地址空间中。
  * 置该进程的状态为就绪，插入就绪队列。

