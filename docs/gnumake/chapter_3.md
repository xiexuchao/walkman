## 变量与宏
  到目前为止，我们已经看过了makefile的变量以及将它们应用在内置和具体规则中的许多范例。不过这些都只是粗浅的例子。变量和宏越复杂，GNU make的功能就越强大。
  
  在我们继续任何探讨之前，最好能先了解make所包含的两种语言。第一种语言用来描述工作目标与必要条件所组成的依存图。 第二种语言是宏语言，用来进行文字的替换。你可能已经熟悉其他的宏语言，像C预处理器、m4、TeX以及宏汇编器。 如同这些其他的宏语言，make允许你为较长的字符序列定义见血并在你的程序中使用该简写，宏处理器将会认出你的简写并将它们替换成展开后的形式。虽然你可以把makefile的变量想成传统程序语言的变量，不过宏变量和传统变量之间是有差别的。宏变量会被就地执行扩展，其所产生的文本字符串还可以做进一步的扩展。 继续读下去，这个差别将会变得更加明显。
  
  一个变量名称几乎可以由任意字符组成，包括大部分的标点符号。即使空格也可以使用，单如果你自认精神正常，就应该避免这么做。事实上只有:、#和=等字符不允许使用在变量名称中。
  
  变量名称是区分大小写的，所以cc和CC所指的是不同的变量。要取得某个变量的值，请用$()扩住该变量的名称。有一个特例: 变量名称若为单一字母则可以省略圆括号，所以请直接使用$letter. 这就是为何自动变量的指定不必使用圆括号。一个原则是: 指定变量名称时应该加上圆括号，避免使用单一字母的变量名称。
  
  你还可以使用花括号来扩展变量，例如${CC}。 事实上，你将会经常看到这种做法，尤其在比较旧的makefile文件中。很难说使用哪个会比较好，所以请选择一使用，选定后务必维持其一致性。有些人的做法会像shell那样，将花括号用于变量的引用，将圆括号用于函数的调用。现代化的makefile多半会使用圆括号，这也是本书将采用的方法。
  
  当变量用来表示用户在命令行上或环境变量中所自定义的常量时，习惯上会全部以大写来编写其名称，单词之间以下划线隔开。 至于只在makefile文件中使用的变量，则会全部以小写来编写其名称，单词之间以下划线符号隔开。最后，在本书中，内含用户自定义函数的变量以及宏都会以小写来编写其名称，单词之间以中划线隔开。其他的命名习惯将会适时加以说明。
```
# 常量
CC      := gcc
MKDIR   := mkdir -p

# 内部变量
sources = *.c
objects = $(subst .c,.o,$(sources))

# 函数
maybe-make-dir    = $(if $(wildcard $1),, $(MKDIR) $1)
assert-not-null   = $(if $1,, $(eroor Illegal null value.))
```

  一个变量的值由赋值符号右边已删除前导空格的所有字符组成。 跟在所有字之后的空格则不会删除。这有时会导致问题，举例来说，如果变量的值包含了跟在后面的空格，而且随后被使用在命令脚本中:
```
LIBRARY = libio.a # LIBRARY 的值包含了一个跟在后面的空格
missing_file:
  touch $(LIBRARY)
  ls -l | grep '$(LIBRARY)'
```
  变量后面跟着空格，加上注释符号之后，这会变得显而易见。对这个makefile运行make, 将会得到如下的结果:
```
bogon:test apple$ make
touch libio.a 
ls -l | grep 'libio.a '
make: *** [missing_file] Error 1
```
  因为grep的搜索字符串也包含了跟在后面的空格，所以无法在ls输出中找到该文件的名称。稍后我们会深入探讨空格的相关细节。现在让我们进一步讨论变量吧.

### 变量的用途
  一般来说，以变量来代表外部程序是一个不错的主意，这让makefile的用户较容易针对它们的环境来改写makefile。举例来说，一个系统上常常会包含awk的各种版本:awk, nawk, gawk.这个时候，你可以建立一个AWK变量来保存awk程序的名称，让makefile较容易使用。此外，如果你的环境以安全为主，那么你最好通过绝对路径来取用外部程序，以避免用户搜索路径所带来的安全问题。比如特洛伊木马版本的系统程序被安装在用户搜索路径中的某处，这么做还可以减少可能的安全问题，当然，绝对路径也会同时降低makefile的可移植性。 你可以根据需求自己决定要怎么做。
  
  变量可以用来保存简单的常熟，也可以用来保存用户自定义的命令序列。例如，下面的设定可用来回报尚未使用的磁盘空间:
```
DF  = df
AWK = awk
free-space := $(DF) . | $(AWK) 'NR == 2 { print $$4 }'
```
  变量的用处还不止这两种，还有很多，稍后我们就会看到。
  
### 变量的类型
  make的变量由两种类型:经简单扩展的变量(simple expanded variable)以及经递归扩展的变量(recursively expanded variable). 你可以用:=赋值运算来定义一个经简单扩展的变量(或简单变量):`MAKE_DEPEND := $(CC) -M`
  之所以称此变量为经简单扩展是因为，一旦make从makefile读进该变量的定义语句，赋值运算符的右边部分会立刻被扩展。赋值运算符的右边部分只要出现make变量的引用就会被扩展，而扩展后产生的文本则会被存储成该变量的值。此行为跟大多数的程序个脚本语言相同。举例来说，此变量被扩展之后一般会变成下面这样: `gcc -M`. 然而，如果上面的CC变量尚未定义，则此变量被扩展之后一般会变成这样:`<space>-M`
  
  $(CC)会被扩展成它的值，也就是空值。变量没有定义并不算错误。事实上，此特性相当有用。大多数的隐含命令都会包含未定义的变量，以作为用户自定义变量的占位符。如果用户并未自定义该变量，它就会被变成空值。现在注意前导的空格。make首先会分析赋值运算符右边的部分，也就是$(CC) -M这个字符串。当变量引用被扩展成空值时，make不会重新扫描该值以及删除前导的空格，于是前导的空格就被保留了下来。
  
  第二种变量类型称为递归扩展的变量。你可以用=赋值运算符来定义一个经过递归扩展的变量(或称递归变量):`MAKE_DEPEND = $(CC) -M`. 之所以称此变量为经递归扩展是因为，make只会读进赋值运算符右边的部分，并将之存储称该变量的值，但不会进行任何扩展的动作，扩展的动作会被延迟到该变量被使用的时候才进行。将此变量称为延后扩展的变量(lazily expanded variable)或许比较恰当，因为扩展的动作会延迟到变量实际被使用的时候才进行。这种扩展方式将会导致意外的结果，即变量的值肯能会变得混乱:
```
MAKE_DEPEND  = $(CC) -M
....

# 稍后
CC = gcc
```
  这样，当MAKE_DEPEND被使用的时候，即使CC并未定义，MAKE_DEPEND在脚本中的值也被扩展成gcc -M.
  
  事实上，对递归变量所进行的并非真的是延后赋值的动作(至少不是一般的延后赋值动作)。每当递归变量被使用时，make就会对它右边的部分进行重新求值的动作。如果变量被定义成简单的常熟，比如前面的MAKE_DEPEND, 做此区别时毫无意义的，因为右边这部分的变量也都是简单的常熟。但试想，如果右边部分的某个变量被用来代表一个所要运行的程序，例如date,那么每当递归变量被扩展，date程序就会被运行，而且每次变量扩展后所产生的也不一样(假设date的每次运行前后间隔至少1秒)。有时候这个特性可能非常有用，有时候这个特性可能非常烦人！
  
### 其他赋值类型
  我们在前面的范例中看到了两种赋值类型，其中=来创建递归变量，而:=用来创建简单变量。此外,make还另外提供了两种赋值运算符:'?='和'+='.
  `?=`运算符称为附带条件的变量赋值运算符(conditional variable assignment operator)，简称条件赋值。此运算符只会在变量的值尚不存在的状况下进行变量要求赋值的动作。
```
# 将所产生的每个文件放到$(PROJECT_DIR)/out目录中
OUTPUT_DIR ?= $(PROJECT_DIR)/out
```
  此处，我们只会在输出目录变量OUTPUT_DIR的值尚不存在的状况下才对它进行赋值的动作。这个功能可能跟环境变量有很好的交互。
  
  `+=`运算符通常被称为附加运算符(append operator). 正如其名，此运算符会将文本附加到变量里。这似乎没有什么特别的，但是当递归变量被使用时，他却是一个重要的特征。尤其是，赋值运算符右边部分的值在不印象变量中原有值的状况下被附加到变量里。你可能会说这有什么大不了的，附加的功能不就在做这件事吗？没错，不过稍安勿躁，事实会有细微的差异。
  
  对简单变量进行附加的动作，事情就变得更加明显。 +=运算符可以被实现成这样:`simple := $(simple) new stuff`
  因为简单变量中的值会被立刻扩展，所以make会扩展$(simple),附加因此而产生的文本，最后进行赋值的动作。但是递归变量会导致一个问题。如果将+=运算符实现成下面，时不允许的。`recursive = $(recursive) new stuff`. 这是一个错误，因为make没有办法妥善地加以处理。如果make存储recursive当前地定义加上new stuff, 则make就不能在运行时再此扩展它。此外，试图扩展一个自我引用地递归变量将会产生一个无限循环。
  所以，+=被特别实现成可将文本附加到 递归变量中并做正确的事。此运算符对于想要将收集到的值传递给变量的任来说特别有用。
  
### 宏
  变量适合用来存储单行形式的值，可是对于多行形式的值，例如命令脚本，如果我们想再不同的地方执行它，该怎么办? 例如，下面这个从java类文件创建java程序库(java archive或简称jar)的命令序列:
```
echo Creating $@...
$(RM) $(TMP_JAR_DIR)
$(MKDIR) $(TMP_JAR_DIR)
$(CP) -r $^ $(TMP_JAR_DIR)
cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
$(JAR) -ufm $@ $(MANIFEST)
$(RM) $(TMP_JAR_DIR)
```

  像这样冗长的命令序列，我们都喜欢在开始的地方输出一个简短的信息，这样可让make的输出较容易阅读。这个信息之后，我们会把类文件收集到一个新的临时目录中。所以，如果该临时目录原本就存在的话就会被我们删除掉，然后我们会创建一个新的临时目录。接下来我们会把必要条件(以及它们的所有子目录)赋值到该临时目录中并切换到该临时目录，再创建jar并以工作目标作为其文件名。我们还会把清淡文件manifest 加入jar并且再最后做清理的工作。毫无疑问，我们并不像让这个命令序列重复出现再makefile文件中，因为这样会给将来的维护带来问题。 虽然我们可以把这个命令序列全部塞进一个递归变量，不过这会给维护造成麻烦，而且当make输出命令行时(整个命令序列会被输出成一大串文本行)，这会造成make的输出难以阅读。
  
  在GNU make中，我们可以通过define指令以创建封装命令序列的方式来解决此问题。使用封装命令序列这个术语或许大家会有些不习惯，所以我们将会称它为宏。 在make中，宏只是用来定义变量的另一种方式，此变量还可以包括内置的换行符号。GNU make的在线使用手册似乎把变量和宏这两个词混用了。 在本书中，我们将会使用宏这个词来指称由define指令所定义的变量，而变量这个词金庸来指称由赋值运算符所定义的变量。
```
define create-jar
  @echo Creating $@...
  $(RM) $(TMP_JAR_DIR)
  $(MKDIR) $(TMP_JAR_DIR)
  $(CP) -r $^ $(TMP_JAR_DIR)
  cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
  $(JAR) -ufm $@ $(MANIFEST)
  $(RM) $(TMP_JAR_DIR)
endef
```
  define指令后看跟着变量名称以及一个换行符号。变量的主体包含了所有命令序列(每一行命令都必须前置一个跳格符号)直到endef关键词出现为止，endef关键词必须自成一行。一个由define创建的变量，就像任何其他的变量一样，会被扩展许多次，除非它被使用在命令脚本的语境中。下面是宏的使用范例:
```
$(UI_JAR): $(UI_CLASSES)
  $(create-jar)
```
  请注意，我们为echo命令前置了一个@符号。当执行命令脚本时，前置@符号的命令行不会被make输出。因此，当我们运行make，它不会输出echo命令本身，只会输出该命令的输出。如果在宏内部使用@前缀，这个前缀字符只会影响使用到它的命令行。然而，如果将这个前缀字符用在宏引用上，则整个宏主体都会被隐藏起来:
```
$(UI_JAR): $(UI_CLASSES)
  @$(create-jar)
```
  当make运行时只会显示:
```
$ make
Creating ui.jar...
```
  稍后我们会在“命令修饰符”一节对@的使用做进一步的讨论。
  
### 何时扩展变量
  稍早我们看到了变量扩展的过程细微差别，这多半取决于变量之前的定义方式以及定义的位置。即使make无法找到任何错误，获得预期以外的结果仍是常有的事情。所以，你可能想知道，扩展变量的规则是什么?这些规则真的有用吗?
  
  当make运行时，它会以两个阶段来完成它的工作。第一个阶段，make会读进makefile以及被引入的任何其他makefile.这个时候，其中所未定义的变量和规则会被加载进make的内部数据库，而且依存图也会被建立起来。第二个阶段，make会分析依存图并且判断需要更新的工作目标，然后执行脚本以完成所需要的更新动作。
  
  当make在处理递归变量或define指令的时候，会将变量里的每一行或宏的主体存储起来，包括换行符号，但不会予以扩展。宏定义里的最后一个换行符并不会被存储称宏的一部分；否则，宏被扩展时make会读进一个额外的换行符号。
  
  当宏被扩展时，make会立即扫描被扩展的文本中是否存在宏或变量的引用，如果存在就予以扩展，如此递归进行下去。如果宏是在命令脚本的语境中被扩展的，则宏主体的每一行都会被插入一个前导的跳格符。
  
  下面是用来处理makefile中的元素何时被扩展的规则:
  * 对于变量赋值(variable assignment), make会在第一阶段读进该行，立即扩展运算符左边的部分。
  * =和?=的右边部分会被延后到它们被使用的时候扩展，并且在第二阶段进行
  * :=的右边部分会立即扩展
  * 如果+=的左边部分原本被定义成一个简单变量，+=的右边部分就会被立即扩展。否则，它的求值动作会被延后。
  * 对于宏定义(define)，宏的变量名称会被立即扩展，宏的主体会被延后到被使用的时候扩展。
  * 对于规则，工作目标和必要条件总是被立即扩展，然而命令总是被延后扩展。
```
###     立即和延后扩展的规则       ###
定义        何时扩展a             何时扩展b
a = b           立即                延后
a ?= b          立即                延后
a := b          立即                立即
a += b          立即                延后或立即
define a
  b...
  b...          立即                延后
  b...
endef
```
  一个通则是: 总是先定义变量和宏，然后再使用它们。尤其是，再工作目标或必要条件中使用变量时，就需要在使用变量之前先予以定义。
  
  举例说明，你会更清楚。假设我们要定义一个free-space的宏。接下来我们会一次说明一个部分，最后再把它们组合在一起。
```
BIN   := /usr/bin
PRINTF:= $(BIN)/printf
DF    := $(BIN)/df
AWK   := $(BIN)/awk
```
  我们定义了三个变量，用来保存红肿所用到的程序名称。为了避免重复，我们把bin目录抽离而成为4个变量。当make读进这四个变量时，它们的右边部分都会被立即扩展，因为它们都是简单变量。BIN变量会被定义在其他三个变量之前，所以它的值会被塞进其他三个变量的值里。
  
  接着，我们定义了free-space宏
```
define free-space
  $(PRINTF) "Free disk space "
  $(DF) . | $(AWK) 'NR == 2 {print $$4 }'
endef
```
  紧跟在define指令之后的变量名称会被立即扩展，但就此例而言，并不需要进行扩展的动作。当make读进宏的主体时会予以储存，但不会将至扩展。
  
  最后，我们会在一个规则中使用free-space这个宏。
```
OUTPUT_DIR := /tmp
$(OUTPUT_DIR)/very_big_file:
  $(free-space)
```
  当$(OUTPUT_DIR)/very_big_file规则被读取时，工作目标和必要条件中所用到所有变量都会被立即扩展。其中，$(OUTPUT_DIR)会被扩展成/tmp, 所以整个工作目标会被变成/tmp/very_big-file.接着，make会读取这个工作目标的命令脚本，它会将前置跳格符的文本行视为命令行，加以读取并将之存储起来，但是不会进行扩展的动作。
  
  下面就是以上所提到的makefile的完整范例。此处可以将makefile的构成元素的次序打乱，以展示make的求值算法。
```
OUTPUT_DIR := /tmp
$(OUTPUT_DIR)/very_big_file:
	$(free-space)

define free-space
	$(PRINTF) "Free disk space "
	$(DF) . | $(AWK) 'NR == 2 { print $$4 }'
endef

BIN		:= /usr/bin
PRINTF	:= $(BIN)/printf
DF		:= /bin/df
AWK		:= $(BIN)/awk
```
  请注意，尽管makefile中各个构成元素的次序似乎搞反了，不过运行起来却毫无问题。这就是递归变量出人意料的效果之一。虽然这相当有用，但这同时也令人相当困惑。 此makefile之所以能运作无误，是因为脚本和宏主体的扩展动作将会被延后到它们实际被使用的时候。因此，它们出现在文件中的先后次序对makefile的运行毫无影响。
  
  第二阶段进行的时候，也就是make读进makefile之后，make会针对每项规则寻找工作目标，进行依存分析以及执行动作。此处只找到了$(OUTPUT_DIR)/very_big_file这个目标，因为此工作目标并未依存于任何必要条件，所以make就会直接执行相应的动作。make所要执行的动作就是$(free-space)这个命令脚本。所以make会将之扩展，整个规则会变成下面这样:
```
/tmp/very_big_file:
  /usr/bin/printf "Free disk space "
  /usr/bin/df . | /usr/bin/awk 'NR == 2 { print $$4 }'
```
  一旦所有的变量都被扩展之后，make会每次执行命令脚本里的一个命令。
  
  事实上，makefile文件中有两处的次序很重要。正如稍早所说，工作目标$(OUTPUT_DIR)/very_big_file会被立即扩展。如果OUTPUT_DIR的定义被放在规则之后，那么工作目标扩展之后就会变成/very_big_file,这或许不是用户想要的结果。同样地，如果BIN的定义被放在AWK等后面，同样也会将另外三个变量变成/printf, /df, /awk.
  
### 工作目标与模式的专属变量
  在makefile运行期间，变量通常只有一个值。对需要经过两个处理阶段的makefile来说是这样没错。第一个阶段，make读进makefile之后，会对变量进行赋值和扩展的动作并建立依存图。第二个阶段，make会分析以及遍历依存图。所以，等到make执行命令脚本的时候，所有变量都已经处理完毕了。 但是如果我们想为特定规则或模式重新定义变量，该怎么办?
  弦子啊，我们想要编译一个需要额外命令行选项-DUSE_NEW_MALLOC=1的文件，但是其他的编译项目并不需要这个额外的命令行选项:
```
gui.o: gui.h
  $(COMPILE.c) -DUSE_NEW_MALLOC=1 $(OUTPUT_OPTION) $<
```
  如上所示，我们解决此问题的办法是赋值编译命令脚本以及为它加入这个必要的选项。如果这个规则有任何变动，或是我们选择以自定义的模式规则来取代这个内置规则，那么我们就必须对这个部分进行更新，不过我们可能会忘掉此事。其次，如果有许多文件需要经过类似的特别处理(假设有100个)，整个工作马上就会变得冗长乏味、易于出错。
  
  为了解决此类问题，make提供了工作目标的专属变量。这些变量的定义会附加在工作目标之上，且只有在该工作目标以及相应的任何必要条件被处理的时候，它们才会发生作用。功过使用此功能，我们可以把前面的例子改写成这个样子:
```
gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o: gui.h
  $(COMPILE.c) $(OUTPUT_OPTION) $<
```
  变量CPPFLAGS内置在C编译规则里，用来保存供C预处理器使用的选项。通过使用+=附加运算符，我们可以把这个新的选项附加到任何已存在的值里。现在可以把编译命令脚本移除:
```
gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o: gui.h
```
  当make处理gui.o这个工作目标的时候，CPPFLAGS的值除了包含它原有的内容，还会包含-DUSE_NEW_ALLOC=1.当make处理完gui.o这个工作目标之后，CPPFLAGS的值将会恢复它原有的内容。
  
  工作目标专属变量的语法如下所示:
```
target ... : variable  = value
target ... : variable := value
target ... : variable += value
target ... : variable ?= value
```
  如你所见，以上的语法只能用来定义工作目标专属变量。此类变量在被赋值之前，并不需要实现存在。
  
  此外，这类变量的赋值动作会延后到开始处理工作目标的时候进行。所以赋值运算符右边的值，可由另一个工作目标的专属变量来设定。同样的，此变量只有在必要条件的处理期间，才会发生作用。
  
### 变量来自何处
  到目前为止，我们所看到的大部分变量都会被明确定义在makefile文件中。起始变量可以更复杂。举例来说，我们曾看到过，变量定义在make命令行上。事实上，make的变量可以有以下几个来源:
  * 文件: 当然，变量可以被定义在makefile中，或是被makefile引入(include ..)
  * 命令行: 你可以直接在make命令行上定义或重新定义变量: `$ make CFLAGS=-g CPPFLAGS='-DBSD -DDEBUG'`
  * 环境
  
  命令行变量: 每个命令行参数中所包含的=，都是一个变量赋值运算符。在命令行上，每个变量赋值运算符的右边部分必须是一个单独的shell参数。如果变量的值(或变量本身)包含空格，则必须为参数加上括号或是规避空格。
  命令行上变量的赋值结果将会覆盖掉环境变量以及makefile文件中的赋值结果。你可以使用:=或=赋值运算符将命令行参数设定成简单或递归变量。此外，如果使用override指令，你还可以要求make采用makefile的赋值结果，而不要采用命令行的赋值结果。
```
# 使用big-endian对象，否则程序会无法运行!
override LDFLAGS = -EB
```
  当然，你只应该在非常紧迫的状况下，忽略用户所需要的赋值动作。(除非你想惹怒用户)
  
  环境：
  当make启动时，所有来自环境的变量都会被自动定义成make的变量。这些变量具有非常低的优先级，所以makefile文件或命令行参数的赋值结果将会覆盖掉环境变量的值。不过，你可以使用--environment-overrides(或-e)命令行选项，让环境变量覆盖掉相应的makefile变量。
  
  当make被递归调用时，有若干来自上层make的变量会通过环境传递给下层的make. 默认情况下，只有原先就来自环境的变量会被导出到下层的环境之后。不过，你只要使用export指令就可以让任何环境变量被导出到环境之后:
  
```
export CLASSPATH := $(HOME)/classes:$(PROJECT)/class
SHELLOPTS = -x
export SHELLOPTS
```
  要将所有变量全部导出，可以这么做: `export`
  请注意，即使这些变量的名称包含了无效的shell变量字符，make也会进行导出的动作。例如:
```
export valid-variable-in-make = Neat!
show-vars:
	env | grep '^valid-'
	valid_variable_in_shell = Great
	invalid-variable-in-shell = Sorry
```


