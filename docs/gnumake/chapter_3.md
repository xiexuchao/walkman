## 变量与宏
  到目前为止，我们已经看过了makefile的变量以及将它们应用在内置和具体规则中的许多范例。不过这些都只是粗浅的例子。变量和宏越复杂，GNU make的功能就越强大。
  
  在我们继续任何探讨之前，最好能先了解make所包含的两种语言。第一种语言用来描述工作目标与必要条件所组成的依存图。 第二种语言是宏语言，用来进行文字的替换。你可能已经熟悉其他的宏语言，像C预处理器、m4、TeX以及宏汇编器。 如同这些其他的宏语言，make允许你为较长的字符序列定义见血并在你的程序中使用该简写，宏处理器将会认出你的简写并将它们替换成展开后的形式。虽然你可以把makefile的变量想成传统程序语言的变量，不过宏变量和传统变量之间是有差别的。宏变量会被就地执行扩展，其所产生的文本字符串还可以做进一步的扩展。 继续读下去，这个差别将会变得更加明显。
  
  一个变量名称几乎可以由任意字符组成，包括大部分的标点符号。即使空格也可以使用，单如果你自认精神正常，就应该避免这么做。事实上只有:、#和=等字符不允许使用在变量名称中。
  
  变量名称是区分大小写的，所以cc和CC所指的是不同的变量。要取得某个变量的值，请用$()扩住该变量的名称。有一个特例: 变量名称若为单一字母则可以省略圆括号，所以请直接使用$letter. 这就是为何自动变量的指定不必使用圆括号。一个原则是: 指定变量名称时应该加上圆括号，避免使用单一字母的变量名称。
  
  你还可以使用花括号来扩展变量，例如${CC}。 事实上，你将会经常看到这种做法，尤其在比较旧的makefile文件中。很难说使用哪个会比较好，所以请选择一使用，选定后务必维持其一致性。有些人的做法会像shell那样，将花括号用于变量的引用，将圆括号用于函数的调用。现代化的makefile多半会使用圆括号，这也是本书将采用的方法。
  
  当变量用来表示用户在命令行上或环境变量中所自定义的常量时，习惯上会全部以大写来编写其名称，单词之间以下划线隔开。 至于只在makefile文件中使用的变量，则会全部以小写来编写其名称，单词之间以下划线符号隔开。最后，在本书中，内含用户自定义函数的变量以及宏都会以小写来编写其名称，单词之间以中划线隔开。其他的命名习惯将会适时加以说明。
```
# 常量
CC      := gcc
MKDIR   := mkdir -p

# 内部变量
sources = *.c
objects = $(subst .c,.o,$(sources))

# 函数
maybe-make-dir    = $(if $(wildcard $1),, $(MKDIR) $1)
assert-not-null   = $(if $1,, $(eroor Illegal null value.))
```

  一个变量的值由赋值符号右边已删除前导空格的所有字符组成。 跟在所有字之后的空格则不会删除。这有时会导致问题，举例来说，如果变量的值包含了跟在后面的空格，而且随后被使用在命令脚本中:
```
LIBRARY = libio.a # LIBRARY 的值包含了一个跟在后面的空格
missing_file:
  touch $(LIBRARY)
  ls -l | grep '$(LIBRARY)'
```
  变量后面跟着空格，加上注释符号之后，这会变得显而易见。对这个makefile运行make, 将会得到如下的结果:
```
bogon:test apple$ make
touch libio.a 
ls -l | grep 'libio.a '
make: *** [missing_file] Error 1
```
  因为grep的搜索字符串也包含了跟在后面的空格，所以无法在ls输出中找到该文件的名称。稍后我们会深入探讨空格的相关细节。现在让我们进一步讨论变量吧.

### 变量的用途
  一般来说，以变量来代表外部程序是一个不错的主意，这让makefile的用户较容易针对它们的环境来改写makefile。举例来说，一个系统上常常会包含awk的各种版本:awk, nawk, gawk.这个时候，你可以建立一个AWK变量来保存awk程序的名称，让makefile较容易使用。此外，如果你的环境以安全为主，那么你最好通过绝对路径来取用外部程序，以避免用户搜索路径所带来的安全问题。比如特洛伊木马版本的系统程序被安装在用户搜索路径中的某处，这么做还可以减少可能的安全问题，当然，绝对路径也会同时降低makefile的可移植性。 你可以根据需求自己决定要怎么做。
  
  变量可以用来保存简单的常熟，也可以用来保存用户自定义的命令序列。例如，下面的设定可用来回报尚未使用的磁盘空间:
```
DF  = df
AWK = awk
free-space := $(DF) . | $(AWK) 'NR == 2 { print $$4 }'
```
  变量的用处还不止这两种，还有很多，稍后我们就会看到。
  
### 变量的类型
  make的变量由两种类型:经简单扩展的变量(simple expanded variable)以及经递归扩展的变量(recursively expanded variable). 你可以用:=赋值运算来定义一个经简单扩展的变量(或简单变量):`MAKE_DEPEND := $(CC) -M`
  之所以称此变量为经简单扩展是因为，一旦make从makefile读进该变量的定义语句，赋值运算符的右边部分会立刻被扩展。赋值运算符的右边部分只要出现make变量的引用就会被扩展，而扩展后产生的文本则会被存储成该变量的值。此行为跟大多数的程序个脚本语言相同。举例来说，此变量被扩展之后一般会变成下面这样: `gcc -M`. 然而，如果上面的CC变量尚未定义，则此变量被扩展之后一般会变成这样:`<space>-M`
  
  $(CC)会被扩展成它的值，也就是空值。变量没有定义并不算错误。事实上，此特性相当有用。大多数的隐含命令都会包含未定义的变量，以作为用户自定义变量的占位符。如果用户并未自定义该变量，它就会被变成空值。现在注意前导的空格。make首先会分析赋值运算符右边的部分，也就是$(CC) -M这个字符串。当变量引用被扩展成空值时，make不会重新扫描该值以及删除前导的空格，于是前导的空格就被保留了下来。
  
  第二种变量类型称为递归扩展的变量。你可以用=赋值运算符来定义一个经过递归扩展的变量(或称递归变量):`MAKE_DEPEND = $(CC) -M`. 之所以称此变量为经递归扩展是因为，make只会读进赋值运算符右边的部分，并将之存储称该变量的值，但不会进行任何扩展的动作，扩展的动作会被延迟到该变量被使用的时候才进行。将此变量称为延后扩展的变量(lazily expanded variable)或许比较恰当，因为扩展的动作会延迟到变量实际被使用的时候才进行。这种扩展方式将会导致意外的结果，即变量的值肯能会变得混乱:
```
MAKE_DEPEND  = $(CC) -M
....

# 稍后
CC = gcc
```
  这样，当MAKE_DEPEND被使用的时候，即使CC并未定义，MAKE_DEPEND在脚本中的值也被扩展成gcc -M.
  
  事实上，对递归变量所进行的并非真的是延后赋值的动作(至少不是一般的延后赋值动作)。每当递归变量被使用时，make就会对它右边的部分进行重新求值的动作。如果变量被定义成简单的常熟，比如前面的MAKE_DEPEND, 做此区别时毫无意义的，因为右边这部分的变量也都是简单的常熟。但试想，如果右边部分的某个变量被用来代表一个所要运行的程序，例如date,那么每当递归变量被扩展，date程序就会被运行，而且每次变量扩展后所产生的也不一样(假设date的每次运行前后间隔至少1秒)。有时候这个特性可能非常有用，有时候这个特性可能非常烦人！
  
### 其他赋值类型
  我们在前面的范例中看到了两种赋值类型，其中=来创建递归变量，而:=用来创建简单变量。此外,make还另外提供了两种赋值运算符:'?='和'+='.
  `?=`运算符称为附带条件的变量赋值运算符(conditional variable assignment operator)，简称条件赋值。此运算符只会在变量的值尚不存在的状况下进行变量要求赋值的动作。
```
# 将所产生的每个文件放到$(PROJECT_DIR)/out目录中
OUTPUT_DIR ?= $(PROJECT_DIR)/out
```
  此处，我们只会在输出目录变量OUTPUT_DIR的值尚不存在的状况下才对它进行赋值的动作。这个功能可能跟环境变量有很好的交互。
  
  `+=`运算符通常被称为附加运算符(append operator). 正如其名，此运算符会将文本附加到变量里。这似乎没有什么特别的，但是当递归变量被使用时，他却是一个重要的特征。尤其是，赋值运算符右边部分的值在不印象变量中原有值的状况下被附加到变量里。你可能会说这有什么大不了的，附加的功能不就在做这件事吗？没错，不过稍安勿躁，事实会有细微的差异。
  
  对简单变量进行附加的动作，事情就变得更加明显。 +=运算符可以被实现成这样:`simple := $(simple) new stuff`
  因为简单变量中的值会被立刻扩展，所以make会扩展$(simple),附加因此而产生的文本，最后进行赋值的动作。但是递归变量会导致一个问题。如果将+=运算符实现成下面，时不允许的。`recursive = $(recursive) new stuff`. 这是一个错误，因为make没有办法妥善地加以处理。如果make存储recursive当前地定义加上new stuff, 则make就不能在运行时再此扩展它。此外，试图扩展一个自我引用地递归变量将会产生一个无限循环。
  所以，+=被特别实现成可将文本附加到 递归变量中并做正确的事。此运算符对于想要将收集到的值传递给变量的任来说特别有用。
  
### 宏
  变量适合用来存储单行形式的值，可是对于多行形式的值，例如命令脚本，如果我们想再不同的地方执行它，该怎么办? 例如，下面这个从java类文件创建java程序库(java archive或简称jar)的命令序列:
```
echo Creating $@...
$(RM) $(TMP_JAR_DIR)
$(MKDIR) $(TMP_JAR_DIR)
$(CP) -r $^ $(TMP_JAR_DIR)
cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
$(JAR) -ufm $@ $(MANIFEST)
$(RM) $(TMP_JAR_DIR)
```

  像这样冗长的命令序列，我们都喜欢在开始的地方输出一个简短的信息，这样可让make的输出较容易阅读。这个信息之后，我们会把类文件收集到一个新的临时目录中。所以，如果该临时目录原本就存在的话就会被我们删除掉，然后我们会创建一个新的临时目录。接下来我们会把必要条件(以及它们的所有子目录)赋值到该临时目录中并切换到该临时目录，再创建jar并以工作目标作为其文件名。我们还会把清淡文件manifest 加入jar并且再最后做清理的工作。毫无疑问，我们并不像让这个命令序列重复出现再makefile文件中，因为这样会给将来的维护带来问题。 虽然我们可以把这个命令序列全部塞进一个递归变量，不过这会给维护造成麻烦，而且当make输出命令行时(整个命令序列会被输出成一大串文本行)，这会造成make的输出难以阅读。
  
  在GNU make中，我们可以通过define指令以创建封装命令序列的方式来解决此问题。使用封装命令序列这个术语或许大家会有些不习惯，所以我们将会称它为宏。 在make中，宏只是用来定义变量的另一种方式，此变量还可以包括内置的换行符号。GNU make的在线使用手册似乎把变量和宏这两个词混用了。 在本书中，我们将会使用宏这个词来指称由define指令所定义的变量，而变量这个词金庸来指称由赋值运算符所定义的变量。
```
define create-jar
  @echo Creating $@...
  $(RM) $(TMP_JAR_DIR)
  $(MKDIR) $(TMP_JAR_DIR)
  $(CP) -r $^ $(TMP_JAR_DIR)
  cd $(TMP_JAR_DIR) && $(JAR) $(JARFLAGS) $@ .
  $(JAR) -ufm $@ $(MANIFEST)
  $(RM) $(TMP_JAR_DIR)
endef
```
  define指令后看跟着变量名称以及一个换行符号。变量的主体包含了所有命令序列(每一行命令都必须前置一个跳格符号)直到endef关键词出现为止，endef关键词必须自成一行。一个由define创建的变量，就像任何其他的变量一样，会被扩展许多次，除非它被使用在命令脚本的语境中。下面是宏的使用范例:
```
$(UI_JAR): $(UI_CLASSES)
  $(create-jar)
```
  请注意，我们为echo命令前置了一个@符号。当执行命令脚本时，前置@符号的命令行不会被make输出。因此，当我们运行make，它不会输出echo命令本身，只会输出该命令的输出。如果在宏内部使用@前缀，这个前缀字符只会影响使用到它的命令行。然而，如果将这个前缀字符用在宏引用上，则整个宏主体都会被隐藏起来:
```
$(UI_JAR): $(UI_CLASSES)
  @$(create-jar)
```
  当make运行时只会显示:
```
$ make
Creating ui.jar...
```
  稍后我们会在“命令修饰符”一节对@的使用做进一步的讨论。
  
### 何时扩展变量
  稍早我们看到了变量扩展的过程细微差别，这多半取决于变量之前的定义方式以及定义的位置。即使make无法找到任何错误，获得预期以外的结果仍是常有的事情。所以，你可能想知道，扩展变量的规则是什么?这些规则真的有用吗?
  
  当make运行时，它会以两个阶段来完成它的工作。第一个阶段，make会读进makefile以及被引入的任何其他makefile.这个时候，其中所未定义的变量和规则会被加载进make的内部数据库，而且依存图也会被建立起来。第二个阶段，make会分析依存图并且判断需要更新的工作目标，然后执行脚本以完成所需要的更新动作。
  
  当make在处理递归变量或define指令的时候，会将变量里的每一行或宏的主体存储起来，包括换行符号，单不会予以扩展。
