## 规则

  前一章中，我们编写了若干规则，用来编译与链接我们的单词计数(word counting)程序。 我们为每个规则定义了一个工作目标，也就是一个需要更新的文件。每个工作目标依存于一组必要条件，这组必要条件也都是文件。 当你要求更新某个工作目标时，如果必要条件中存在时间戳在工作目标的时间戳之后的文件， make就会执行相应规则里的命令脚本。因为某个规则的工作目标可以时另一个规则的必要条件，所以这样的工作目标和必要条件将会形成依存图(dependency graph). 建立即处理依存图，并据此更新特定的工作目标，就是make所要做的事情。
  
  规则对make而言十分重要，make允许你使用各种类型的规则。具体规则(explicit rule)，就像我们在上一章所编写的规则，用来指定需要更新的工作目标:如果必要条件中存在时间戳在此工作目标的时间戳之后的文件，make就会对它进行更新的动作。这将会是你最常使用的规则类型。 模式规则(pattern rule)中所使用的是通配符而不是明确的文件名称，这让make得以对模式相符的工作目标应用该规则，进行必要的更新动作。隐含规则(implicit rule)可以是模式规则，也可以是内置于make的后缀规则(suffix rule). 有了这些内置于make的规则可让makefile的编写变得更为容易，因为对于工作目标的更新，make已经知道许多常见文件类型、后缀以及更新工作目标的程序。 至于静态模式规则(static pattern rule), 它就像正规模式规则一样，只不过它们只能应用在一串特定的工作文件中。
  
  GNU make可作为许多其他版本的make的替代品，它特别针对兼容性提供了若干功能。后缀规则最初是make用来编写通则(general rule)的方法。尽管GNU make也支持后缀规则，不过为了更完整及一般化，它考虑以模式规则来替换。
  
### 具体规则
  你编写的规则多半会是具体规则，以特定的文件作为工作目标和必要条件。每个规则都可以有多个工作目标。这意味着，每个工作目标所具备的必要条件可以跟其他工作目标的一样。如果这些工作目标尚未被更新，则make将会为它们执行同一组更新动作。例如:
```
vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h
```
  这代表vpath.o和variable.o与同一组C头文件具有依存关系。这一行等效于:
```
vpath.o: make.h config.h getopt.h gettext.h dep.h
variable.o: make.h config.h getopt.h gettext.h dep.h
```
  这两个工作目标将会被分开处理。只要有任一个目标文件尚未被更新(也就是说，任何一个头文件的时间戳在该目标文件的之后)，则make将会执行规则中所指定的命令以便更新该目标文件。
  
  你不必将规则一次定义完全(all at once). 每当make看到一个工作目标，就会将该工作目标与其必要条件加入依存图。 如果make所看到的工作目标已经存在于依存图中，则任何额外的必要条件都会被附加到该工作目标在依存图中的项目里。 对较简单的应用来说，这个特性可用来断开太长的规则以增进makefile的可读性:
```
vpath.o: make.h config.h getopt.h gettext.h dep.h
variable.o: make.h config.h getopt.h gettext.h dep.h
```
  对较复杂的应用来说，必要条件可以组成自看似无关的文件:
```
# 确定vpath.c被编译之前lexer.c已经创建好了
vpath.o: lexer.c
...

# 以特殊的标记来编译vpath.c
vpath.o: vpath.c
  $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<
...

# 引入另一个程序所产生的依存关系
include auto-generated-dependencies.d
```

  第一个规则之处，每当lexer.c被更新后，vpath.o就必须被更新(这或许是因为产生lexer.c的过程中会有其他副作用)。 这个规则还可以用来确保必要条件的更新动作总是在工作目标之前被实施(注意规则的双向作用。就其正向作用而言，此规则之处，若lexer.c已经被更新，则需要对vpath.o执行更新的动作；就其反向作用而言，此规则之处，如果我们需要建立或使用vpath.o, 首先必须确定lexer.c已经更新)。 这个规则应该就近放在lexer.c处理规则的旁边，好让开发人员能够注意到这个微妙的关系。稍后，vpath.o的编译规则会被放到其他编译规则中。 此规则的命令用到了三个make变量。你将会看到更多的make变量，不过现在你只需要知道，一个变量可以是一个美元符号后面跟着单一字符(character)，也可以是一个美元符号后面紧跟着一个加圆括号的单词(稍后，我将会在本章做进一步的说明，并且会在第三章做更多的说明)。最后，.o文件和.h文件的依存关系是从另一个文件(这个文件产生自外部程序)引入到makefile的。
  
### 通配符
  当你有一长串文件要指定时，为了简化此过程，make提供了通配符, 此功能也被称为文件名模式匹配(globbing). make的通配符如同Bourne shell的~, *, ?, [...], [^...]。举例来说：
```
*.* : 表示文件名中包含点号的所有文件。
?: 表示代表任何单一字符
[...]: 代表一个字符集。
[^...]: [...]的补集。
~: 当前用户的主目录(home directory).
~username: username的主目录
```

  每当make在工作目标、必要条件或命令脚本等语境(context)中看到通配符，就会自动扩展通配符。在其他语境中，你可以通过函数的调用手动扩展通配符。如果你向创建适应能力较强的makefile, 统配符非常有用。举例来说，如果不想手动列出一个程序里的所有文件，你就可以使用通配符: 
```
prog: *.c
  $(CC) -o $@ $^
```
  不过通配符的使用务必谨慎为之，因为一不小心就会有误用的危险。比如: `*.o: constants.h`
  
  这个规则的意图很明显: 所有的目标文件皆依存于头文件constants.h。 不过，如果工作目录中当前并未包含任何目标文件，则通配符扩展后会变成下面这样: `: constants.h`
  这是个合法的make表达式，而且它本身并不会产生错误信息。实现此规则的正确方法，就是针对源文件使用通配符(因为它们总是存在的)以及将之转换成一串目标文件。
  
  最后值得注意的是，当模式出现在工作目标或必要条件中时，是由make进行通配符的扩展。然而，当模式出现子啊命令中时， 是由subshell进行扩展的动作。 区分这两种情况有时会变得很重要，因为make会在读取makefile的时候立即扩展通配符，但是shell只会在执行命令的时候扩展通配符。 当有许多复杂的文件操作需要进行时，这两种文件扩展动作将会有很大的差别。
  
  
