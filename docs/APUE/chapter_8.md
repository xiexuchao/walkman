## 第八章 进程控制

### 8.1 引言
  本章介绍Unix的进程控制，包括创建新进程、执行程序和进程终止。还将说明进程的各种ID--实际、有效和保存的用户和组ID,以及它们如何受到进程控制原语的影响。本章也包括了解释器文件和system函数。本章以大多数unix系统所提供的进程会计机制结束。这使我们从一个不同角度了解进程控制功能。

### 8.2 进程标识符
  每个进程都有一个非负整型的唯一进程ID, 因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以确保其唯一性。
  
  进程ID虽然唯一，但是还是会重用的， 它们的ID会变成候选者以待重用。很多Unix系统实现延迟重用算法， 然而，新创建的进程赋予的ID都是和最近终止的进程ID不同的。 这样就防止新进程错误， 使用了前面使用的相同ID.
  
  有某些专用的进程:进程ID为0的是调度进程，常常被称为交换进程(swapper). 该进程并不执行任何磁盘上的程序--它是内核的一部分，因此也被称为系统进程。进程ID为1的通常是init进程，在自举过程(bootstrap)结束时由内核调用.该进程的程序文件在unix早期版本中是/etc/init, 在较新版本中是/sbin/init. 此进程负责在内核自举后启动一个unix系统。init通常读与系统有关的初始化文件(/etc/rc*文件),并将系统引导到一个状态(例如多用户)，init进程绝不会终止，它是一个普通的用户进程(与交换进程不同，它不是内核中的系统进程)，但是它以超级用户特权运行。本章稍后会说明init如何称为所有孤儿进程的父进程。
  
  在某些Unix的虚存实现中，进程ID 2是页精灵进程(pagedeamon), 此进程负责支持虚存系统的请求页操作。与交换进程一样，页精灵进程也是内核进程。
  
  除了进程ID, 每个进程还有一些其他标识符。下列函数返回这些标识符。
```
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);       /** 返回调用进程的进程ID **/
pid_t getppid(void);      /** 返回进程的父进程ID **/
uid_t getuid(void);       /** 调用进程的实际用户ID **/
uid_t geteuid(void);      /** 调用进程的有效用户ID **/
gid_t getgid(void);       /** 调用进程的实际组ID **/
gid_t getegid(void);      /** 调用进程的有效组ID **/
```
  注意，这些函数都没有出错返回，在下一节中讨论fork函数时，将进一步讨论父进程ID, 4.4节中已经讨论了实际和有效用户及组ID.
  
  
### 8.3 fork函数
  一个现存进程调用fork函数是unix内核创建一个新进程的唯一方法(这并不适用于前节提及的交换进程、init进程和页精灵进程。 这些进程是由内核作为自举过程的一部分以特殊方式创建的)。
```
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```
  由fork创建的新进程被称为子进程(child process). 该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值是新子进程的进程ID. 将子进程ID返回给父进程的理由是:因为一个进程的子进程可以多于一个，所以没有一个函数使一个进程可以获得其所有子进程的进程ID. fork使子进程得到返回值0的理由是: 一个进程只会有一个父进程，所以子进程总是可以调用getppid()以获得其父进程的进程ID(进程ID 0总是由交换进程使用，所以一个子进程的进程ID不可能为0)。
  子进程和父进程继续执行fork之后的指令。子进程是父进程的复制品。例如，子进程获得父进程数据空间、堆和栈的复制品。注意，这是子进程所拥有的拷贝。父子进程并不共享这些存储空间部分。如果正文段是只读的，则父子进程共享正文段。
  
  现在很多实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着exec。作为替代，使用了在写时复制(Copy-On-Write, COW)的技术。这些区域由父子进程共享，而且内核将它们的存取许可权改变为只读的。如果有进程试图修改这些区域，则内核为有关部分，典型的是虚存系统中的页， 做一个拷贝。
```
#include "apue.h"

#include <sys/types.h>

int glob = 6;       /** external variable in initialized data **/
char buf[] = "a write to stdout\n";

int
main(void)
{
    int var; /** automatic variable on the stack **/
    pid_t pid;


    var = 88; 
    if(write(STDOUT_FILENO, buf, sizeof(buf) - 1) != sizeof(buf) - 1)
        err_sys("write error");

    printf("before fork\n");     /** we don't flush stdout **/
    if((pid = fork()) < 0)
        err_sys("fork error");
    else if(pid == 0) { /** child process **/
        glob++;         /** modify variables **/
        var++;
    } else {
        sleep(2);
    }   

    printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
    exit(0);
}
```
  编译并运行结果如下:
```
bogon:process apple$ ./proc1 
a write to stdout
before fork
pid = 77066, glob = 7, var = 89
pid = 77065, glob = 6, var = 88
bogon:process apple$ ./proc1 > temp.txt
bogon:process apple$ cat temp.txt
a write to stdout
before fork
pid = 77069, glob = 7, var = 89
before fork
pid = 77068, glob = 6, var = 88
```
  一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。如果要求父子进程之间相互同步，则要求某种形式的进程间通信。上面程序中，父进程使自己休眠2秒钟，以使子进程先执行。但并不保证2秒钟已经足够，在后面8.8节说明竞争条件时，还将谈及这一问题及其他类型的同步方法。在10.6节中，在fork之后将用信号使父子进程同步。
  注意，上面程序中的fork与I/O函数之间的关系。回忆第三章中所述，write函数是不带缓存的。因为在fork之前调用write, 所以其数据洗到标准输出一次。但是，标准I/O库是带缓存的。当以交互方式运行该程序时，只得到printf输出行一次，其原因是标准输出缓存由新行符刷新。但是当标准输出重定向到一个文件时，该行数据仍在缓存中，然后在父进程数据空间复制到子进程的过程中时，该缓存数据也被复制到子进程中。于是那时父子进程各自有了带该行内容的缓存。在exit之前的第二个print将其数据添加到现存的缓存中。当每个进程终止时，其缓存中的内容被写到相应的文件中。
  
  文件共享，对上面程序需要注意的另一点是: 在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是所有由父进程打开的描述符都被复制到子进程中。父子进程每个相同的打开描述符共享一个文件表项。
  
  考虑下述情况，一个进程打开了三个不同文件，它们分别是:标准输入、标准输出和标准出错，在从fork返回时，我们有了如图8-1中所示的安排。
  这种共享文件的方式使父子进程对同一个文件使用了一个文件位移量。考虑下述情况:一个进程fork了一个子进程，然后等待子进程终止。假定，作为普通处理的一部分，父子进程都向标准输出执行写操作。如果父进程使其标准输出重定向(很可能是由shell实现的)，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的位移量。在我们所考虑的例子中，当父进程等待子进程时，子进程写到标准输出；而在子进程终止后，父进程也写到标准输出上，并且直到其输出会添加在子进程缩写数据之后。如果父子进程不共享同一文件位移量，这种形式的交互就很难实现。
  
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/fork_fds.png)
  
  
### 8.4 vfork函数

### 8.5 exit函数


### 8.6 wait和waitpid函数

### 8.7 waitid函数

### 8.8 wait3和wait4函数

### 8.9 竞态条件

### 8.10 exec函数

### 8.11 改变用户ID和组ID

### 8.12 解释器文件

### 8.13 system函数

### 8.14 进程会计

### 8.15 用户标识符

### 8.16 进程调度

### 8.17 进程时间

### 8.18 总结
