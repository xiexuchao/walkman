## 第八章 进程控制

### 8.1 引言
  本章介绍Unix的进程控制，包括创建新进程、执行程序和进程终止。还将说明进程的各种ID--实际、有效和保存的用户和组ID,以及它们如何受到进程控制原语的影响。本章也包括了解释器文件和system函数。本章以大多数unix系统所提供的进程会计机制结束。这使我们从一个不同角度了解进程控制功能。

### 8.2 进程标识符
  每个进程都有一个非负整型的唯一进程ID, 因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以确保其唯一性。
  
  进程ID虽然唯一，但是还是会重用的， 它们的ID会变成候选者以待重用。很多Unix系统实现延迟重用算法， 然而，新创建的进程赋予的ID都是和最近终止的进程ID不同的。 这样就防止新进程错误， 使用了前面使用的相同ID.
  
  有某些专用的进程:进程ID为0的是调度进程，常常被称为交换进程(swapper). 该进程并不执行任何磁盘上的程序--它是内核的一部分，因此也被称为系统进程。进程ID为1的通常是init进程，在自举过程(bootstrap)结束时由内核调用.该进程的程序文件在unix早期版本中是/etc/init, 在较新版本中是/sbin/init. 此进程负责在内核自举后启动一个unix系统。init通常读与系统有关的初始化文件(/etc/rc*文件),并将系统引导到一个状态(例如多用户)，init进程绝不会终止，它是一个普通的用户进程(与交换进程不同，它不是内核中的系统进程)，但是它以超级用户特权运行。本章稍后会说明init如何称为所有孤儿进程的父进程。
  
  在某些Unix的虚存实现中，进程ID 2是页精灵进程(pagedeamon), 此进程负责支持虚存系统的请求页操作。与交换进程一样，页精灵进程也是内核进程。
  
  除了进程ID, 每个进程还有一些其他标识符。下列函数返回这些标识符。
```
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);       /** 返回调用进程的进程ID **/
pid_t getppid(void);      /** 返回进程的父进程ID **/
uid_t getuid(void);       /** 调用进程的实际用户ID **/
uid_t geteuid(void);      /** 调用进程的有效用户ID **/
gid_t getgid(void);       /** 调用进程的实际组ID **/
gid_t getegid(void);      /** 调用进程的有效组ID **/
```
  注意，这些函数都没有出错返回，在下一节中讨论fork函数时，将进一步讨论父进程ID, 4.4节中已经讨论了实际和有效用户及组ID.
  
  
### 8.3 fork函数
  一个现存进程调用fork函数是unix内核创建一个新进程的唯一方法(这并不适用于前节提及的交换进程、init进程和页精灵进程。 这些进程是由内核作为自举过程的一部分以特殊方式创建的)。
```
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```
  由fork创建的新进程被称为子进程(child process). 该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值是新子进程的进程ID. 将子进程ID返回给父进程的理由是:因为一个进程的子进程可以多于一个，所以没有一个函数使一个进程可以获得其所有子进程的进程ID. fork使子进程得到返回值0的理由是: 一个进程只会有一个父进程，所以子进程总是可以调用getppid()以获得其父进程的进程ID(进程ID 0总是由交换进程使用，所以一个子进程的进程ID不可能为0)。
  子进程和父进程继续执行fork之后的指令。子进程是父进程的复制品。例如，子进程获得父进程数据空间、堆和栈的复制品。注意，这是子进程所拥有的拷贝。父子进程并不共享这些存储空间部分。如果正文段是只读的，则父子进程共享正文段。
  
  现在很多实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着exec。作为替代，使用了在写时复制(Copy-On-Write, COW)的技术。这些区域由父子进程共享，而且内核将它们的存取许可权改变为只读的。如果有进程试图修改这些区域，则内核为有关部分，典型的是虚存系统中的页， 做一个拷贝。
```
#include "apue.h"

#include <sys/types.h>

int glob = 6;       /** external variable in initialized data **/
char buf[] = "a write to stdout\n";

int
main(void)
{
    int var; /** automatic variable on the stack **/
    pid_t pid;


    var = 88; 
    if(write(STDOUT_FILENO, buf, sizeof(buf) - 1) != sizeof(buf) - 1)
        err_sys("write error");

    printf("before fork\n");     /** we don't flush stdout **/
    if((pid = fork()) < 0)
        err_sys("fork error");
    else if(pid == 0) { /** child process **/
        glob++;         /** modify variables **/
        var++;
    } else {
        sleep(2);
    }   

    printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
    exit(0);
}
```
  编译并运行结果如下:
```
bogon:process apple$ ./proc1 
a write to stdout
before fork
pid = 77066, glob = 7, var = 89
pid = 77065, glob = 6, var = 88
bogon:process apple$ ./proc1 > temp.txt
bogon:process apple$ cat temp.txt
a write to stdout
before fork
pid = 77069, glob = 7, var = 89
before fork
pid = 77068, glob = 6, var = 88
```
  一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。如果要求父子进程之间相互同步，则要求某种形式的进程间通信。上面程序中，父进程使自己休眠2秒钟，以使子进程先执行。但并不保证2秒钟已经足够，在后面8.8节说明竞争条件时，还将谈及这一问题及其他类型的同步方法。在10.6节中，在fork之后将用信号使父子进程同步。
  注意，上面程序中的fork与I/O函数之间的关系。回忆第三章中所述，write函数是不带缓存的。因为在fork之前调用write, 所以其数据洗到标准输出一次。但是，标准I/O库是带缓存的。当以交互方式运行该程序时，只得到printf输出行一次，其原因是标准输出缓存由新行符刷新。但是当标准输出重定向到一个文件时，该行数据仍在缓存中，然后在父进程数据空间复制到子进程的过程中时，该缓存数据也被复制到子进程中。于是那时父子进程各自有了带该行内容的缓存。在exit之前的第二个print将其数据添加到现存的缓存中。当每个进程终止时，其缓存中的内容被写到相应的文件中。
  
  文件共享，对上面程序需要注意的另一点是: 在重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上，fork的一个特性是所有由父进程打开的描述符都被复制到子进程中。父子进程每个相同的打开描述符共享一个文件表项。
  
  考虑下述情况，一个进程打开了三个不同文件，它们分别是:标准输入、标准输出和标准出错，在从fork返回时，我们有了如图8-1中所示的安排。
  这种共享文件的方式使父子进程对同一个文件使用了一个文件位移量。考虑下述情况:一个进程fork了一个子进程，然后等待子进程终止。假定，作为普通处理的一部分，父子进程都向标准输出执行写操作。如果父进程使其标准输出重定向(很可能是由shell实现的)，那么子进程写到该标准输出时，它将更新与父进程共享的该文件的位移量。在我们所考虑的例子中，当父进程等待子进程时，子进程写到标准输出；而在子进程终止后，父进程也写到标准输出上，并且直到其输出会添加在子进程缩写数据之后。如果父子进程不共享同一文件位移量，这种形式的交互就很难实现。
  
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/fork_fds.png)
  
  如果父子进程写到同一个描述符文件，但又没有任何形式的同步(例如使父进程等待子进程)，那么它们的输出就会相互混合(假定所用的描述符是在fork之前打开的)。虽然这种情况是有可能发生的，但这并不是常用的操作方式。
  在fork之后处理文件描述符有两种常见的情况:
  1. 父进程等待子进程完成。这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读写操作的任一共享描述符的文件位移量已经做了相应更新。
  2. 父子进程各自执行不同的程序段。在这种情况下，在fork之后，父子进程各自关闭它们不需要使用的文件描述符，并且不干扰对方使用的文件描述符。这种方法是网络服务进程中进场使用的。
  除了打开文件之外，很多父进程的其他性质也由子进程继承:
  * 实际用户ID, 实际组ID, 有效用户ID,有效组ID
  * 添加组ID
  * 进程组ID
  * 对话期ID
  * 控制终端
  * set-user-ID和set-group-ID标志
  * 当前工作目录
  * 根目录
  * 文件方式创建屏蔽字
  * 信号屏蔽和排列
  * 对任一打开文件描述符的在执行时关闭标志
  * 环境
  * 连接的共享存储段
  * 资源限制
  
  父子进程的区别是:
  * fork的返回值
  * 进程ID
  * 不同的父进程ID
  * 子进程的tms_utime, tms_stime, tms_cutime以及tms_ustime设置为0
  * 父进程设置的锁，子进程不继承
  * 子进程的未决告警被清除
  * 子进程的未决信号集设置为空集。
  
  其中很多特性至今尚未讨论过，我们将在以后几章中对它们进行说明。

  使fork失败的两个主要原因是: 
  * 系统中已经有了太多的进程(通常意味着某个方面出了问题)
  * 该实际用户ID的进程总数超过了系统限制。CHILD_MAX规定了每个实际用户ID在任一时刻可具有的最大进程数。
  
  fork有两种用法:
  1. 一个父进程希望复制自己，使父子进程同时执行不同的代码段。这在网络服务进程中是最常见的--父进程等待委托着的服务请求。当这种请求到达时，父进程调用fork， 使子进程处理此请求。父进程则继续等待下一个服务请求。
  2. 一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程在从fork返回后立即调用exec。
  某些操作系统将2中的两个操作(fork之后执行exec)组合成一个，并称其为spawn. Unix将这两个操作分开，因为在很多场合需要单独使用fork，然后并不跟随exec. 另外，将这两个操作分开，使得子进程在fork和exec之间可以更改自己的属性。例如I/O重定向、用户ID、信号排列等。在第14章有很多这方面的例子。
  
### 8.4 vfork函数
  vfork函数的调用序列和返回值与fork相同，但两者的语义不同。
```
  vfork起源于较早的4BSD虚存版本。在Leffler等[1989]的5.7节中指出:"虽然它是特别有效率的，但是vfork的语义很奇特，
  通常人为它具有结构上的缺陷。"
  
  尽管如此SVR4和4.3+BSD仍支持vfork.
  某些系统具有头文件<vfork.h>, 当调用vfork时，应当包括该头文件。
```
  vfork用于创建一个新进程，而该进程的目的是exec一个新程序。vfork和fork一样都是创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec(或exit),于是也就不会存访该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。这种工作方式在某些Unix的页式虚存实现中提高了效率。
  vfork和fork之间的另一个区别在于:vfork保证子进程先运行，在它调用exec或exit之后，父进程才可能被调度运行。(如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁)。
```
#include "apue.h"

#include <sys/types.h>

int glob = 6;       /** external variable in initialized data **/
char buf[] = "a write to stdout\n";

int
main(void)
{
    int var; /** automatic variable on the stack **/
    pid_t pid;


    var = 88; 
    if(write(STDOUT_FILENO, buf, sizeof(buf) - 1) != sizeof(buf) - 1)
        err_sys("write error");

    printf("before fork\n");     /** we don't flush stdout **/
    if((pid = vfork()) < 0)
        err_sys("vfork error");
    else if(pid == 0) { /** child process **/
        glob++;         /** modify variables **/
        var++;
        _exit(0);
    } else {
        sleep(2);
    }   

    printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
    exit(0);
}
```
  运行程序得到：
```
bogon:process apple$ ./vfork 
a write to stdout
before fork
pid = 78116, glob = 7, var = 89
```
  子进程对变量glob和var做增1操作，结果改变了父进程中的变量值。因为子进程在父进程的地址空间中运行，所以这并不惊讶。但是其作用的确与fork不同。
  注意，上面子进程调用了_exit(0), 而不是exit(0). _exit并不执行标准I/O缓存的刷新操作。如果用exit而不是_exit，则程序不会输出最后一行。(抱歉，在我的macbook上面结果都一样，不知道why?)
  从中可见，父进程printf的输出消失了。其原因是子进程调用了exit, 它刷新关闭了所有标准I/O流，这包括标准输出。虽然这是由子进程执行的，但却是在父进程的地址空间中进行的，所以所有受到影响的标准I/O FILE对象都是在父进程中的。当父进程调用printf时，标准输出已被关闭了，于是printf返回-1.
  

### 8.5 exit函数
  前面章节我们说过，进程有三种正常终止法及两种异常终止法。
  1. 正常终止
  <ol>
    <li>在main函数内执行return语句。这等效于调用exit.</li>
    <li>调用exit函数。其操作包括调用各终止处理程序(终止处理程序在调用atexit时登录)，然后关闭所有标准I/O流等。因为ANSI C并不处理文件描述符、多进程(父子进程)以及作业控制，所以这一定义对Unix系统而言是不完整的。</li>
    <li>调用_exit系统调用函数。此函数由exit调用，他处理Unix特定细节。</li>
  </ol>
  2. 异常终止
  <ol>
    <li>调用abort. 它产生SIGABRT信号，所以是下一种异常终止的一个特例</li>
    <li>当进程接收到某个信号时。进程本身(例如调用abort)、其他进程和内核都能产生传送到某一进程的信号。例如，进程越出其地址空间访问存储单元，或者除以0，内核就会为该进程产生相应的信号。</li>
  </ol>

  不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开文件描述符，释放它所使用的存储器等。
  对上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于exit和_exit，这是依靠传递给它们的退出状态(exit status)参数来实现的。在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的终止状态(termination status). 在任意一种情况下， 该终止进程的父进程都能用wait或waitpid函数取得其终止状态。
  
  注意，这里使用了退出状态(它是传向exit或_exit的参数，或main的返回值)和终止状态两个术语，以表示有所区别。在最后调用_exit时，内核将其退出状态转换成终止状态。下一节我们会介绍父进程检查子进程的终止状态的不同方法。如果子进程正常终止，则父进程可以获得子进程的退出状态。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/c_startup_terminate.png)
  
  在说明fork函数时，一定是一个父进程生成一个子进程。上面又说明了子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，则将如何呢? 其回答是对于其父进程已经终止的所有进程，它们的父进程都改变为init进程。我们称这些进程由init进程领养。其操作过程大致是:一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止的进程的子进程，如果是，则该进程的父进程ID就更改为1(init的进程ID).这种处理方法保证了每个进程有一个父进程。
  
  另一个我们关心的情况是如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢? 对此问题的回答是内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到有关信息。这种信息至少包括进程ID, 该进程的终止状态，以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储器，关闭其所有打开文件。在Unix术语中，一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占有的资源)的进程称为僵尸进程(zombie).ps(1)命令将僵死进程的状态打印为Z. 如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，否则这些子进程就会变成僵死进程。
  
  最后需要考虑的一个问题是: 一个由init进程领养的进程终止时会发生什么?它会不会变成一个僵死进程?对此问题的回答是"否", 因为init被编写称只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中有很多僵死进程。当提及"一个init的子进程"时，这指的是init直接产生的进程(例如getty进程)，或者是其父进程已终止，由init领养的进程。
  
  

### 8.6 wait和waitpid函数
  当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。父进程可以忽略该信号，或者提供一个信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作是忽略它。第10章将说明这些选择项。现在需要知道的是调用wait或waitpid的进程可能会:
  * 阻塞(如果其所有子进程都还在运行)
  * 带子进程的终止状态立即返回(如果一个子进程已终止，正等待父进程存取其终止状态)。
  * 出错立即返回(如果它没有任何子进程)。
  
  如果进程由于接到SIGCHLD信号而调用wait，则可期望wait会立即返回。但是如果在一个任一时刻调用wait, 则进程可能会阻塞。

```
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
```
  这两个函数的区别是:
  * 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选择项，可使得调用者不阻塞。
  * waitpid并不等待第一个终止的子进程--它有若干各

### 8.7 waitid函数

### 8.8 wait3和wait4函数

### 8.9 竞态条件

### 8.10 exec函数

### 8.11 改变用户ID和组ID

### 8.12 解释器文件

### 8.13 system函数

### 8.14 进程会计

### 8.15 用户标识符

### 8.16 进程调度

### 8.17 进程时间

### 8.18 总结
