## 第七章 进程环境

### 7.1 引言
  下一章将介绍进程控制原语，在此之前需要先了解进程的环境。本章中将学习:当执行程序时，其main函数是如何被调用的，命令行参数是如何传送给执行程序的；典型的存储器布局是什么样式；如何分配另外的存储空间；进程如何使用环境变量；进程终止的不同方式等等。
  另外还将说明longjmp和setjmp函数以及它们与栈的交互作用。本章结束之前，还将查看进程的资源限制。

### 7.2 main函数
  C程序总是从main函数开始执行。main函数的原型是: int main(int argc, char **argv);
  其中argc是命令行参数的数目，argv是指向参数的各个指针所构成的数组。
  
  当内核启动C程序时(使用一个exec函数。)在调用main函数前先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地址--这是由连接编辑程序设置的，而连接编辑程序则由C编译程序(通常是cc)调用。启动例程从内核获得命令行参数和环境变量值，然后为调用main函数做好安排。

### 7.3 进程终止
  有五种方式使进程终止:
  1. 正常终止
  <ol>
    <li>从main返回</li>
    <li>调用exit</li>
    <li>调用_exit</li>
  </ol>
  2. 异常终止
  <ol>
    <li>调用abort</li>
    <li>由一个信号终止</li>
  </ol>

  上节提及的启动例程是这样编写的，使得从main返回后立即调用exit()函数。如果将启动例程以C代码形式表示(实际上该例程常常用汇编语言编写)，则它调用main函数的形式可能是:`exit( main(argc, argv) );

#### 7.3.1 exit和_exit函数
#### 7.3.2 atexit函数
  这两节参见前面的文章，这里待补充。

### 7.4 命令行参数
  当执行一个程序时， 调用exec的进程可以将命令行参数传递给该新程序。这是Unix SHELL的一部分常规操作。在前几章很多实例，我们已经看到了这一点。
```
#include "apue.h"
int main(int argc, char **argv)
{
  int i;
  for(i = 0; i < argc; i++) {
    printf("argv[%d]: %s\n", i, argv[i]);
  }

  for(i = 0; argv[i] != NULL; i++) {
    printf("argv[%d]: %s\n", i, argv[i]);
  }
}
```
  ANSI C和POSIX.1都要求argv[argc]是一个空指针。这就意味着，后面的循环处理`for(i = 0; argv[i] != NULL; i++)`是ok的。

### 7.5 环境表
  每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以null结束的字符串地址。全局变量environ则包含了该指针数组的地址。
  `extern char **environ;`
  例如，如果该环境变量包含五个字符串，那么它看起来可能如图7-2所示。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/environ_demo.png)
  
  其中每个字符串的结束处都有一个null字符。我们称environ为环境指针，指针数组为环境表，其中各指针指向的字符串为环境字符串。
  
  按照惯例，环境由: name=value这样的字符串组成，这与图7-2中所示相同。大多数预定义名完全由大写字母组成，但这只是一个惯例。
  在历史上，大多数unix系统对main函数提供了第三个参数，他就是环境表地址:
  `int main(int argc, char **argv, char **envp);`
  因为ANSI C规定main只有两个参数，而且第三个参数与全局变量environ相比也没有带来更多益处，所以POSIX.1也规定应使用environ而不使用第三个参数。 通常用getenv和putenv函数来存取特定的环境变量，而不是用environ变量。但是，如果要查看整个环境，则必须使用environ指针。

### 7.6 C程序的内存空间布局
  由于历史原因，C程序一直由以下几部分组成:
  * 正文段。 这是由CPU执行的机器指令部分。通常，正文段是可共享的，所以即使进场执行的程序(如文本编辑程序、C编译程序、shell等)在存储器中也只需要有一个副本，另外，正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令。
  * 初始化数据段。通常将此段称为数据段，它包含了程序中需赋初值的变量。例如，C程序中任何函数之外的说明: int maxcount = 99; 使此变量以初值存放在初始化数据段中。
  * 非初始化数据段. 通常将此段称为bss段， 这一名词来源于早期汇编程序的一个操作符，意思是"block started by symbol(由符号开始的块)"，在程序开始执行之前，内核将此段初始化为0，函数外的说明: long sum[1000]; 使此变量存放在非初始化数据段中。
  * 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。 每次函数调用时，其返回地址、以及调用者的环境信息(例如某些机器寄存器)都存放在栈中。 然后，新被调用的函数在栈上为其自动和临时变量分配存储空间。通过这种方式使用栈，C函数可以递归调用。
  * 堆。 通常在堆中进行动态存储分配。由于历史上形成的惯例，堆位于非初始化数据段顶和栈之间。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/storage_structure.png)

  对于VAX上的4.3+BSD, 正文段从0位置开始，栈顶则在0x7fffffff之下开始。在VAX机器上，堆顶和栈底之间未用的虚地址空间很大。
  从上图可看到未初始化数据段的内容并不存放在磁盘程序文件中。需要存放在磁盘程序文件中的段只有正文段和初始化数据段。
  size(1)命令报告正文段、数据段和bss段的长度。例如: `size /bin/cc /bin/sh`
  
  总结:
  典型的存储器安排 正文，初始化字段， 为初始化(仅定义的变量)， 堆(动态分配的存储空间)，栈(自动变量及函数调用时所需保存的信息)
  
### 7.7 共享库
  现在，很多Unix系统支持共享库。Arnold说明了系统V上共享库的一个早期实现，Gingell等则说明了SunOS上的另一个实现。共享库使得可执行文件中不再需要包含常用的库函数，而只需在所有进程都可存取的存储区中保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，用动态连接方法将程序与共享库函数相连接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序进行重新连接编译。(假定参数的数目和类型都没有发生变化)
  
  不同的系统使用不同的方法使说明程序是否要使用共享库。比较典型的有cc(1)和ld(1)命令的可选项。作为长度方面发生变化的例子，下列可执行文件(典型的hello.c程序)先用无共享库的方式创建,再用共享库的方式创建，则可执行文件的正文和数据段的长度都显著减少。
  
  

### 7.8 内存分配
  ANSI C说明了三个用于存储空间动态分配的函数。
  1. malloc: 分配指定字节数的存储区。此存储区中的初始值不确定。
  2. calloc: 未指定长度的对象，分配能容纳其指定个数的存储空间。该空间中的每一位都初始化为0.
  3. realloc: 更改以前分配区的长度(增加或减少)。当增加长度时，可能需要将以前分配区的内容移动到另一个足够大的区域，而新增区域的初始值则不确定。
```
#include <stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);
void *realloc(void *ptr, size_t newsize);

void free(void *ptr);
```
  这三个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象。例如，在一个特定的系统上，如果最苛刻的对齐要求是double, 则对齐必须在8的倍数的地址单元处，那么这三个函数返回的指针都应这样对齐。
  
  

### 7.9 环境变量

### 7.10 setjmp和longjmp函数

### 7.11 getrlimit和setrlimit函数

### 7.12 总结
