## 第16章 网络IPC: Sockets

### 16.1 引言
  上一章我们考察了各种Unix系统所提供的经典进程间通信机制(IPC): 管道、FIFO、消息队列、信号量以及共享存储。这些机制允许在同一台计算机上运行的进程可以相互通信。本章将考察不同计算机(通过网络连接)上的进程相互通信的机制:网络间通信(network IPC).
  
  在本章中，我们将描述套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机还是在不同的计算机上。实际上，这正是套接字接口设计目标之一:同样的接口可以用于计算机间通信，也可用于计算机内通信。尽管套接字接口可以采用许多不同的网络协议进行通信，但本章的讨论限制在因特网事实上的通信标准:TCP/IP协议栈。
  
  POSIX.1中指定的套接字API是基于4.4BSD套接字接口的。尽管这些年套接字接口有些细微的变化，但是当前的套接字接口与20世纪80年代早期4.2BSD所引入的接口很类似。
  
  本章仅是一个套接字API的概述。

### 16.2 Socket描述符
  套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序使用套接字描述符访问套接字。套接字描述符在Unix系统中被当作是一种文件描述符。事实上，许多处理文件描述符的函数(如read/write)都可以处理套接字描述符。
```
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```
  参数domain去定通信的特性，包括地址格式。16.1图总结了由POSIX.1指定的各个域。各个域都有自己标识地址的格式，而表示各个域的常数都以AF_开头，意指地址族(address family).
  
  我们将在17.2节讨论Unix域。大多数系统还定义了AF_LOCAL域，这是AF_UNIX的别名。AF_UNSPEC域可代表任何域。历史上，有些平台支持其他网络协议，如AF_IPX域代表的NetWare协议族，但这些协议的域常数没有被POSIX.1标准定义。
```
图 16.1
--------------------------
域          描述
--------------------------
AF_INET     IPv4因特网域
AF_INET6    IPv6因特网域
AF_UNIX     Unix域
AF_UNSPEC   未指定
```
  参数type确定套接字的类型，进一步确定通信特征。下图总结了由POSIX.1定义的套接字类型，但在实现中可以自由添加其他类型的支持。
```
----------------------------------------------------------------------------
类型            描述
----------------------------------------------------------------------------
SOCK_DGRAM      固定长度的、无连接的、不可靠的报文传递
SOCK_RAW        IP协议的数据报接口(在POSIX.1中是可选的)
SOCK_SEQPACKET  固定长度的、有序的、可靠的、面向连接的报文传递
SOCK_STREAM     有序的、可靠的、双向的、面向连接的字节流
----------------------------------------------------------------------------
```
  参数protocol通常是0，表示为给定的域和套接字类型选择默认协议。当对同一个域和套接字类型支持多个协议时，可以使用protocol选择一个特定协议。在AF_INET通信域中，套接字类型SOCK_STREAM的默认协议是传输控制协议(TCP). 在AF_INET通信域中，套接字类型SOCK_DGRAM的默认协议是UDP. 下面列出了为因特网域套接字定义的协议:
```
----------------------------------------------------------------------------
协议          描述
----------------------------------------------------------------------------
IPPROTO_IP    IPv4网际协议
IPPROTO_IPV6  IPv6网际协议(在POSIX.1中为可选)
IPPROTO_ICMP  因特网控制报文协议(Internet Control Message Protocol)
IPPROTO_RAW   原始IP数据包协议(在POSIX.1中为可选)
IPPROTO_TCP   传输控制协议
IPPROTO_UDP   用户数据报协议(User Datagram Protocol)
```

  对于数据报(SOCK_DGRAM)接口，两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文。
  因此数据包提供了一个无连接的服务。另一方面，字节流(SOCK_STREAM)需要在交换数据之前，在本地套接字和通信的对等进程套接字之间建立一个逻辑连接。
  
  数据报是自包含报文。发送数据报近似于给某人邮寄信件。你能邮寄很多新，但你不能保证传递的次序，并且可能有些信件会丢失在路上。每封信件包含接受者地址，使这封信件独立于所有其他信件。每封信件可能送达不同的接受者。
  相反，使用面向连接的协议通信就像与对方打电话。首先，需要通过电话建立一个连接，连接建立好之后，彼此能双向的通信。每个连接是端到端的通信链路。对话中不包含地址信息，就向呼叫两端存在一个点对点虚拟连接，并且连接本身按时特定的源和目的地。
  
  SOCK_STREAM套接字提供字节流服务，所以应用程序分辨不出报文的界限。这意味着从SOCK_STREAM套接字读数据时，它也许不会返回所有由发送进程所写的字节数。最终可以获得发送过来的所有数据，但也许要通过若干次函数调用才能得到。
  
  SOCK_SEQPACKET套接字和SOCK_STREAM套接字很类似，只是从该套接字得到的是基于报文的服务而不是字节流服务。这意味着从SOCK_SEQPACKET套接字接收的数据量与对方所发送的一致。流控制传输协议(SCTP)提供了因特网域上的顺序数据报服务。
  
  SOCK_RAW套接字提供一个数据报接口，用于直接反问下面的网络层(即因特网域中的IP层)。使用这个接口时，应用程序负责构造自己的协议头部，这是因为传输协议(如TCP和UDP)被绕过了。的那个创建一个原始套接字时，需要有超级用户特权，这样可以防止恶意应用程序绕过内奸安全机制来创建报文。
  
  调用socket与调用open相类似。在两种情况下，均可获得用于I/O的文件描述符。当不再需要该文件描述符时，调用close来关闭对文件或套接字的访问，并且释放该描述符以便重新使用。
  
  虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。 下图总结了到目前为止所讨论的大多数以文件描述符为参数的函数使用套接字描述符的行为。未指定和由实现定义的行为通常意味着该函数对套接字描述符无效。例如lseek不能以套接字描述符为参数，因为套接字不支持文件偏移量的概念。
```
---------------------------------------------------------------
函数                        使用套接字描述符时的行为
---------------------------------------------------------------
close                       释放套接字
dup和dup2                   和一般文件描述符一样复制
fchdir                      失败，并且将errno设置为ENOTDIR
fchmod                      未指定
fchown                      由实现定义
fcntl                       支持一些命令，包括F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_GETFL, F_GETOWN, F_SETFD, F_SETFL和F_SETOWN.
fdatasync, fsync            由实现定义
fstat                       支持一些stat结构成员，但如何支持由实现定义
ftruncate                   未指定
ioctl                       支持部分命令，依赖于底层设备驱动
lseek                       由实现定义(通常失败会将errno设置为ESPIPE)
mmap                        未指定
poll                        正常工作
pread,pwrite                失败时会将errno设置为ESPIPE
read,readv                  与没有任何标志位的recv等价
select                      正常工作
write,writev                与没有任何标志位的send等价
```
  套接字通信是双向的。可以采用shutdown函数来禁止一个套接字的I/O.
```
#include <sys/socket.h>
int shutdown(int sockfd, int how);
```
  如果how是SHUT_RD(关闭读端)，那么无法从套接字读取数据。如果how是SHUT_WR(关闭写端)，那么无法使用套接字发送数据。如果how是SHUT_RDWR, 则既无法读取数据，又无法发送数据。能够关闭一个套接字，为何还使用shutdown呢?这里有若干理由。首先，只有最后一个活动引用关闭时，close才释放网络端点。这意味着如果复制一个套接字(如采用dup),要知道关闭了最后一个引用它的文件描述符才会释放这个套接字。而shutdown允许使一个套接字处于不活动状态，和引用它的文件描述符数目无关。其次，有时可以很方便的关闭套接字双向传输中的一个方向。例如，如果想让所通信的进程能够确定数据传输何时结束，可以关闭该套接字的写端，然后通过该套接字读端仍可以继续接受数据。

### 16.3 寻址
  上一节学习了如何创建和销毁一个套接字。在学习用套接字做一些有意义的事情之前，需要知道如何标识一个目标通信进程。进程标识有两部分组成。一部分是计算机的网络地址，她可以帮助标识网络上我们想与之通信的计算机。另一部分是该计算机上用端口号表示的服务，她可以帮助标识特定的进程。
  
### 16.3.1 字节序
  与同一台计算机上的进程进行通信时，一般不用考虑字节序。字节序时一个处理器架构特性，用于指示像整数这样的大数据类型内部的字节如何排序。图16-5显示了一个32位整数中的字节序是如何排序的。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/bytes_order_in32bit_system.png)
  
  如果处理器架构支持大端字节序，那么最大字节地址出现在最低有效字节上。小端字节序则相反:最低有效字节包含最小字节地址。注意，不管字节如何排序，最高有效字节总在左边，最低有效字节总在右边。因此，如果想给一个32位整数赋值0x04030201,不管字节序如何，最高有效字节都将包含4，最低有效字节都将包含1.

### 16.4 连接确立

### 16.5 数据传输

### 16.6 Socket选项

### 16.7 Out-of-Band数据

### 16.8 非阻塞和异步I/O

### 16.9 总结

