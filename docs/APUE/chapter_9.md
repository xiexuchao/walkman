## 第九章 进程关系

### 9.1 引言
  在上一章，我们已经了解了进程之间具有关系。首先，每个进程有一个父进程。当子进程终止时，父进程会得到通知并能取得子进程的退出状态。在8.6节说明waitpid函数时，我们也提到了进程组，已如何等待进程组中的任一个进程终止。
  
  本章将更详细地说明进程组以及POSIX.1引进地对话期新概念。还将介绍登录shell和所有从登录shell启动地进程之间地关系。
  
  在说明这些关系时不可能不谈及信号，而谈及信号又需要很多本章介绍的概念。如果你还不熟悉Unix信号，则可能先要浏览以下第10章。

### 9.2 终端登录
  先看一看登录到Unix系统时所执行的各个程序。在早期的Unix系统中，例如V7,用户用亚终端进行登录。终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)。 在这两种情况下，登录都经由内核中的终端设备驱动程序。例如，在PDP-11尚常用的设备是DH-11和DZ-11. 因为连接到主机上的终端数已经确定，所以同时的登录数也就有了已知的上限。 下面说明的登录过程适用于使用一个RS-232终端登录到Unix系统中。

#### 9.2.1 4.3+BSD终端登录
  登录过程在过去15年中并没有多少改变。系统管理者插棍件一个通常每年岗位/etc/ttys的文件，其中，每隔终端设备有一行，每一行说明设备名和传到getty程序的参数,这些参数说明了终端的波特率等。当系统bootstrap的时候，内核创建进程ID 1, 也就是init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork, 它所生成的子进程则执行程序getty. 这种情况示于下图:
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/init_fork_getty.png)
  
  图中各个进程的实际用户ID和有效用户ID都是0(也就是它们都具有超级用户特权)。init以空环境执行getty程序。
  
  getty对终端设备调用open函数，以读、写方式将终端打开。如果设别是调制解调器，则open可能会在设备驱动程序中滞留，知道用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0，1，2就被设置到该设备。然后getty输出login:之类的信息，并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度(波特率)。关于getty程序以及有关数据文件地细节，请参阅Unix手册。
  
  当用户键入了用户名后，getty就完成了。然后它类似于下列地方式调用login程序:
  `execle("/usr/bin/login", "login", "-p", username, (char *)0, envp)`
  (在gettytab文件中可能会有一些选择项使其调用其他程序，但系统默认是login程序)。init以一个空环境调用getty. getty以终端名(例如TERM=foo, 其中终端foo的类型取自getttytab文件)和在gettytab中的环境字符串为login创建一个环境(envp参数). -p标志通知login保留传给它的环境，也可以将其他环境字符串加到该环境中，但是不要替换它。下图显示了lgoin刚被调用后这些进程的状态
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/init_login_status.png)
  
  因为最初的init进程具有超级用户优先权，所以所有进程都有超级用户优先权。上图中三个进程的进程ID相同，因为进程ID不会因为执行exec而改变。并且，出了最初的init进程，所有的进程均有一个父进程ID.
  
  login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass以显示提示Password:， 接着读用户键入的口令(自然，禁止回送用户键入的口令)。他调用crypt(3)将用户键入的口令加密，并与该用户口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数1调用exit表示登录失败。父进程init了解到子进程的终止情况后，将再次调用fork, 其后又跟随着执行getty, 对此终端重复上述过程。
  
  如果用户正确登录，login就将当前工作目录更改为该用户的起始目录(chdir). 它也调用chown改变该终端的所有权限，使该用户称为该所有者和组所有者。将对该终端设备的存取许可权改变成:用户读、写和组写。 调用setgid及initgroups设置进程的组id. 然后用login得到的所有信息初始化环境:起始目录(HOME), shell(SHELL),用户名(User和Logname)，以及一个系统默认路径PATH. 最后，login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell,其方式类似于:
  `execl("/bin/sh", "-sh", (char *) 0);`
  
  argv[0]的第一个字符-是一个标志，表示该shell被调用为登录shell. shell可以查看此字符，并相应地修改其启动过程。
  
  login所做的比上面说的要多。它可选地打印message-of-the-day文件，检查新邮件以及其他一些功能。但是考虑到本书的内容，我们主要关心上面所说的功能。
  
  

### 9.3 网络登录
  

### 9.4 进程组

### 9.5 会话

### 9.6 控制终端

### 9.7 tcgetpgrp, tcsetpgrp和tcgetsid函数

### 9.8 作业控制

### 9.9 shell执行程序

### 9.10 孤儿进程组

### 9.11 FreeBSD实现

### 9.12 总结
