## 第九章 进程关系

### 9.1 引言
  在上一章，我们已经了解了进程之间具有关系。首先，每个进程有一个父进程。当子进程终止时，父进程会得到通知并能取得子进程的退出状态。在8.6节说明waitpid函数时，我们也提到了进程组，已如何等待进程组中的任一个进程终止。
  
  本章将更详细地说明进程组以及POSIX.1引进地对话期新概念。还将介绍登录shell和所有从登录shell启动地进程之间地关系。
  
  在说明这些关系时不可能不谈及信号，而谈及信号又需要很多本章介绍的概念。如果你还不熟悉Unix信号，则可能先要浏览以下第10章。

### 9.2 终端登录
  先看一看登录到Unix系统时所执行的各个程序。在早期的Unix系统中，例如V7,用户用亚终端进行登录。终端或者是本地的(直接连接)或者是远程的(通过调制解调器连接)。 在这两种情况下，登录都经由内核中的终端设备驱动程序。例如，在PDP-11尚常用的设备是DH-11和DZ-11. 因为连接到主机上的终端数已经确定，所以同时的登录数也就有了已知的上限。 下面说明的登录过程适用于使用一个RS-232终端登录到Unix系统中。

#### 9.2.1 4.3+BSD终端登录
  登录过程在过去15年中并没有多少改变。系统管理者插棍件一个通常每年岗位/etc/ttys的文件，其中，每隔终端设备有一行，每一行说明设备名和传到getty程序的参数,这些参数说明了终端的波特率等。当系统bootstrap的时候，内核创建进程ID 1, 也就是init进程。init进程使系统进入多用户状态。init读文件/etc/ttys，对每一个允许登录的终端设备，init调用一次fork, 它所生成的子进程则执行程序getty. 这种情况示于下图:
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/init_fork_getty.png)
  
  图中各个进程的实际用户ID和有效用户ID都是0(也就是它们都具有超级用户特权)。init以空环境执行getty程序。
  
  getty对终端设备调用open函数，以读、写方式将终端打开。如果设别是调制解调器，则open可能会在设备驱动程序中滞留，知道用户拨号调制解调器，并且线路被接通。一旦设备被打开，则文件描述符0，1，2就被设置到该设备。然后getty输出login:之类的信息，并等待用户键入用户名。如果终端支持多种速度，则getty可以测试特殊字符以便适当地更改终端速度(波特率)。关于getty程序以及有关数据文件地细节，请参阅Unix手册。
  
  当用户键入了用户名后，getty就完成了。然后它类似于下列地方式调用login程序:
  `execle("/usr/bin/login", "login", "-p", username, (char *)0, envp)`
  (在gettytab文件中可能会有一些选择项使其调用其他程序，但系统默认是login程序)。init以一个空环境调用getty. getty以终端名(例如TERM=foo, 其中终端foo的类型取自getttytab文件)和在gettytab中的环境字符串为login创建一个环境(envp参数). -p标志通知login保留传给它的环境，也可以将其他环境字符串加到该环境中，但是不要替换它。下图显示了lgoin刚被调用后这些进程的状态
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/init_login_status.png)
  
  因为最初的init进程具有超级用户优先权，所以所有进程都有超级用户优先权。上图中三个进程的进程ID相同，因为进程ID不会因为执行exec而改变。并且，出了最初的init进程，所有的进程均有一个父进程ID.
  
  login能处理多项工作。因为它得到了用户名，所以能调用getpwnam取得相应用户的口令文件登录项。然后调用getpass以显示提示Password:， 接着读用户键入的口令(自然，禁止回送用户键入的口令)。他调用crypt(3)将用户键入的口令加密，并与该用户口令文件中登录项的pw_passwd字段相比较。如果用户几次键入的口令都无效，则login以参数1调用exit表示登录失败。父进程init了解到子进程的终止情况后，将再次调用fork, 其后又跟随着执行getty, 对此终端重复上述过程。
  
  如果用户正确登录，login就将当前工作目录更改为该用户的起始目录(chdir). 它也调用chown改变该终端的所有权限，使该用户称为该所有者和组所有者。将对该终端设备的存取许可权改变成:用户读、写和组写。 调用setgid及initgroups设置进程的组id. 然后用login得到的所有信息初始化环境:起始目录(HOME), shell(SHELL),用户名(User和Logname)，以及一个系统默认路径PATH. 最后，login进程改变为登录用户的用户ID(setuid)并调用该用户的登录shell,其方式类似于:
  `execl("/bin/sh", "-sh", (char *) 0);`
  
  argv[0]的第一个字符-是一个标志，表示该shell被调用为登录shell. shell可以查看此字符，并相应地修改其启动过程。
  
  login所做的比上面说的要多。它可选地打印message-of-the-day文件，检查新邮件以及其他一些功能。但是考虑到本书的内容，我们主要关心上面所说的功能。
  
  回忆再8.10节中对setuid函数的讨论，因为setuid是由超级用户调用的，它更改所有三个用户ID: 实际、有效和保存的用户ID.login在早时间调用的setgid对所有三个组ID也有同样的效果。
  
  到此为止，登录用户的登录shell开始运行。其父进程ID是init进程ID(进程ID 1),所以当此登录shell终止时，init会得到通知(SIGCHLD信号)，它会对该终端重复全部上述过程。登录shell的文件描述符0，1和2设置为终端设备。

### 9.3 网络登录
  

### 9.4 进程组
  每个进程出了有一个进程ID之外，还属于一个进程组，第10章讨论信号时还会涉及进程组。进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID, 进程组ID类似于进程ID, 它是一个正整数，并可存放在pid_t数据类型中。 函数getpgrp返回调用进程的进程组ID.
```
#include <sys/types.h>
#include <unistd.h>

pid_t getpgrp(void);
```
  每个进程组有一个组长进程。组长进程的标识是，其进程组ID等于其进程ID.
  
  进程组组长可以创建一个进程组，创建该组中的进程，然后终止。 只要在某个进程组中有一个进程存在，则该进程组就存在， 这与其组长进程是否终止无关。 从进程组创建开始到其中最后一个进程离开为止的时间区称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以参加另一个进程组。
  
  进程调用setpgrp可以参加一个现存的组或创建一个新进程组。(下一节中将说明用setsid也可以创建一个新的进程组)。
```
#include <sys/types.h>
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);
```
  这将pid进程的进程组ID设置为pgid. 如果这两个参数相等，则由pid指定进程变成进程组组长。
  一个进程只能为它自己或它的子进程设置进程组ID. 在它的子进程调用了exec后，它就不再能改变该子进程的进程组ID.
  
  如果pid是0，则使用调用者的进程ID. 另外，如果pgid是0， 则由pid指定的进程ID被用作为进程组ID.
  
  如果系统不支持作业控制，那么就不定义_POSIX_JOB_CONTROL, 在这种情况下，此函数返回出错，errno设置为ENOSYS.
  
  在大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID,然后使其子进程设置自己的进程组ID.这个调用中有些是冗余的，但这样做可以保证父子进程在进一步操作之前，子进程都进入了该进程组。如果不这样做的话，那么就产生一个竞态条件，因为它依赖于哪一个进程先执行。
  
  当讨论信号的时候，我们会看如何将信号发送给单个进程或进程组。 同样，waitpid则可以用来等待一个进程或指定进程组中的一个进程。

### 9.5 会话
  对话期(session)是一个或多个进程组的集合。例如，可以有如图9-6中所示的安排。其中，在一个对话期中有三个进程组。通常由shell的管道线将几个进程编成一组的。例如可能是下面形式的shell命令形成图中的情形:
  `proc1 | proc2 & proc3 | proc4 | proc5`
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/proc_session.png)
  
  进程调用setsid函数就可以建立一个新对话期。
```
#include <sys/types.h>
#include <unistd.h>

pid_t setsid(void);
```
  如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话期，结果为:
  * 此进程变成该新对话期首进程(session leader,对话期首进程是创建该对话期的进程).此进程是该新对话期中的唯一进程。
  * 此进程成为一个新进程组的组长进程。新进程组ID是调用进程的进程ID.
  * 此进程没有控制终端。如果在调用setsid之前此进程有一个控制终端，那么这种联系也被解除。
  
  如果调用此函数的进程已经是一个进程组组长，则此函数返回错误。为了保证不处于这种情况，通常线调用fork, 然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组ID,而其进程ID则是新分配的，两者不可能相等，所以这就保证了子进程不可能是一个进程组的组长。

### 9.6 控制终端
  对话期和进程组有一些其他特性:
  * 一个对话期可以有一个单独的控制终端。这通常是我们在其上登录的终端设备或伪终端设备
  * 建立与控制终端连接的对话期首进程，被称之为控制进程。
  * 一个对话期中有几个进程组可以被分成一个前台进程组以及一个或几个后台进程组。
  * 无论何时键入中断键或退出键，则会造成将中断信号或退出信号传至前台进程组的所有进程。
  * 如果中断界面检测到调制解调器已经脱开连接，则将挂断信号送至控制进程(对话期首进程)
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/proc_group_session_console.png)

### 9.7 tcgetpgrp, tcsetpgrp和tcgetsid函数

### 9.8 作业控制

### 9.9 shell执行程序

### 9.10 孤儿进程组

### 9.11 FreeBSD实现

### 9.12 总结
