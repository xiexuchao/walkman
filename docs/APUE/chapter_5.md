## 第五章 标准I/O类库

### 5.1 引言
  本章说明标准I/O库。 因为不仅在Unix而且在很多操作系统上都实现此库，所以它由ANSI C标准说明。标准I/O库处理很多细节，例如缓存分配，以及优化长度执行I/O等。这样使用户不必担心如何选择使用正确的块长度。标准I/O库是在系统调用基础上构造的，它便于用于使用，但是如果不较深入的了解库的操作，也会带来一些问题。

### 5.2 流和FILE对象
  在第三章中，所有I/O函数都是针对文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续读的I/O操作。而对于标准I/O库，它们的操作则是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相结合了。
  
  当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针。该对象通常是一个结构，它包含了I/O库为管理该流所需要的所有信息:用于实际I/O的文件描述符，指向流缓存的指针，缓存的长度，当前在缓存中的字符数，出错标志等等。
  
  应用程序没有必要检验FILE对象。为了引用一个流，需要将FILE指针作为参数传递给每个标准I/O函数。在本书中，我们称指向FILE对象的指针为文件指针。
  
  在本章中，我们以Unix系统为例，说明标准I/O库。正如前述，此标准库已移除到除Unix以外的很多系统中。但是为了说明该类库实现的一些细节，我们选择Unix实现作为典型进行介绍。

### 5.3 标准输入、标准输出和标准出错
  对一个进程预先定义了三个流，它们自动地可为进程使用:标准输入流、标准输出流、标准出错流。在3.2节，我们曾用文件描述符STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO分别表示它们。
  这三个标准I/O流通过与定义文件指针stdin, stdout, stderr加以引用。这三个文件指针同样定义在stdio.h文件中。

### 5.4 缓冲区
  标准I/O提供缓冲地目的是尽可能减少使用read和write调用的数量。它也对每个I/O流自动地进行缓存管理，避免了应用程序需要考虑这一点所带来地麻烦。不幸的是，标准I/O库令人最感迷惑的也是它的缓存。
  
  标准I/O库提供了三种类型的缓存:
  1. 全缓存。 这种情况下， 当填满标准I/O缓存后才进行实际I/O操作。对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的。 在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需要使用的缓存。<p>aaa</a>
  2. 

### 5.5 打开流

### 5.6 读、写流

### 5.7 每次一行I/O

### 5.8 标准I/O效率

### 5.9 二进制I/O

### 5.10 定位流

### 5.11 格式化I/O

### 5.12 实现细节

### 5.13 临时文件

### 5.14 内存流

### 5.15 标准流可替换品

### 5.16 总结
