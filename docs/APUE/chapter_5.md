## 第五章 标准I/O类库

### 5.1 引言
  本章说明标准I/O库。 因为不仅在Unix而且在很多操作系统上都实现此库，所以它由ANSI C标准说明。标准I/O库处理很多细节，例如缓存分配，以及优化长度执行I/O等。这样使用户不必担心如何选择使用正确的块长度。标准I/O库是在系统调用基础上构造的，它便于用于使用，但是如果不较深入的了解库的操作，也会带来一些问题。

### 5.2 流和FILE对象
  在第三章中，所有I/O函数都是针对文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续读的I/O操作。而对于标准I/O库，它们的操作则是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相结合了。
  
  当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针。该对象通常是一个结构，它包含了I/O库为管理该流所需要的所有信息:用于实际I/O的文件描述符，指向流缓存的指针，缓存的长度，当前在缓存中的字符数，出错标志等等。
  
  应用程序没有必要检验FILE对象。为了引用一个流，需要将FILE指针作为参数传递给每个标准I/O函数。在本书中，我们称指向FILE对象的指针为文件指针。
  
  在本章中，我们以Unix系统为例，说明标准I/O库。正如前述，此标准库已移除到除Unix以外的很多系统中。但是为了说明该类库实现的一些细节，我们选择Unix实现作为典型进行介绍。

### 5.3 标准输入、标准输出和标准出错
  对一个进程预先定义了三个流，它们自动地可为进程使用:标准输入流、标准输出流、标准出错流。在3.2节，我们曾用文件描述符STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO分别表示它们。
  这三个标准I/O流通过与定义文件指针stdin, stdout, stderr加以引用。这三个文件指针同样定义在stdio.h文件中。

### 5.4 缓冲区
  标准I/O提供缓冲地目的是尽可能减少使用read和write调用的数量。它也对每个I/O流自动地进行缓存管理，避免了应用程序需要考虑这一点所带来地麻烦。不幸的是，标准I/O库令人最感迷惑的也是它的缓存。
  
  标准I/O库提供了三种类型的缓存:
  1. 全缓存。 这种情况下， 当填满标准I/O缓存后才进行实际I/O操作。对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的。 在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需要使用的缓存。<p>术语刷新flush说明标准I/O缓存的写操作。缓存可由标准I/O例程自动地刷新(当填满一个缓存时)，或者可以调用函数fflush刷新一个流。 值得引起注意地是在Unix中，刷新有两种意思。在标注I/O库方面，刷新意味着将缓存中地内容写到磁盘上(该缓存可以只是局部填写的). 在终端驱动程序方面，刷新表示丢弃已存放在缓存中的数据。</a>
  2. 行缓存。 在这种情况下，当在输入和输出中遇到新行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(用标准I/O fputc函数)，但只有在写了一行之后才进行实际I/O操作。当流涉及一个终端时(例如标准输入和标准输出)，典型的使用行缓存。<p>对于行缓存有两个限制。第一个是:因为标准I/O库用来收集每一行的缓存长度是固定的，所以只要填满了缓存，那么即使还没有写一个新行符，也进行I/O操作。第二个是: 任何时候只要通过标准输入输出库要求从(a)一个不带缓存的流，或者(b)一个行缓存的流(它预先要求从内核得到数据)得到输入数据，那么就会造成刷新所有行缓存的输出流。 在(b)中带了一个在括号中的说明的理由是，所需的数据可能已经在该缓存中，它并不要求内核在需要该数据时才进行该操作。很明显，从不带缓存的一个流中进行输入((a))要求当时从内核得到数据。</p>
  3. 不带缓存。标准I/O库不对字符进行缓存。如果用标准I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。标准出错流stderr通常是不带缓存的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符。
  
  ANSI C要求下列缓存特征:
  1. 当且仅当标准输入和标准输出并不涉及交互作用设备时，它们才是全缓存的。
  2. 标准出错绝不会是全缓存的。
  
  但是，这并没有告诉我们如果标准输入和输出涉及交互作用设备时，它们是不带缓存的还是行缓存的，以及标准输出是不带缓存的，还是行缓存的。SVR4和4.3+BSD的系统默认使用下列类型的缓存:
  * 标准出错是不带缓存的
  * 如果涉及终端设备的其他流，则它们是行缓存的，否则是全缓存的。
  
  对任何一个给定的流，如果我们并不喜欢这些系统默认，则可以调用下列两个函数中的一个更改缓存类型:
```
#include <stdio.h>
void setbuf(FILE *fp, char *buf);
int setvbuf(FILE *fp, char *buf, int mode, size_t size);
```
  这些函数一定要在流已经被打开后调用,而且也应在对该流执行任何一个其他操作之前调用。
  可以使用setbuf函数打开或关闭缓存机制。为了带缓存进行I/O, 参数buf必须指向一个长度为BUFSIZE的缓存(该常数定义在stdio.h中)。通常在此之后该流就是全缓存的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓存的。为了关闭缓存，将buf设置为NULL.
  
  使用setvbuf，我们可以精确的说明所需的缓存类型。这是依靠mode参数实现的:
  * _IOFBF 全缓存
  * _IOLBF 行缓存
  * _IONBF 不带缓存
  
  如果指定一个不带缓存的流，则忽略buf和size参数。如果指定全缓存或行缓存，则buf和size可以选择地指定一个缓存以及长度。如果该流是带缓存的，而buf是NULL, 则标准I/O库将自动地为流分配适当长度地缓存。适当长度指地是由struct结构中地成员st_blksize所指定的值。如果系统不能为该流决定此值(例如若此流涉及一个设备或一个管道)，则分配长度为BUFSIZE的缓存。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/setbuf_setvbuf.png)
  
  要了解，如果在一个函数中分配一个自动变量类的标准I/O缓存，则从该函数返回之前，必须关闭该流。另外，SVR4将缓存的一部分用于自己的管理操作，所以可以存放在缓存中的实际数据字节少于size. 一般而言，应由系统选择缓存的长度，并自动分配缓存。在这样处理时，标准I/O库在关闭此流时将自动释放此缓存。

  在任何时候都可以强制刷新一个流fflush(FILE *fp); 此函数使该流所有未写的数据都被传递至内核。作为一种特殊情形，如若fp是NULL, 则此函数刷新所有输出流。

### 5.5 打开流
  下列三个函数可用于打开一个标准I/O流
```
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
              All three return: file pointer if OK, NULL on error
```
  这三个函数的区别是:
  1. fopen打开路径名由pathname指定的一个文件
  2. freopen在一个特定的流上(由fp指示)打开一个指定的文件(路径名由pathname指示)，如若该流已经打开，则先关闭该流。此函数一般用于将一个指定的文件打开为一个预定义的流: 标准输入流、标准输出流或标准错误流。
  3. fdopen取一个现存的文件描述符(我们可能从open, dup, dup2, fcntl或pipe函数得到此文件描述符)，并使一个标准的I/O流与该描述符相结合。 此函数常用于由创建管道和网络通信通道函数获得的描述符。因为这些特殊类型的文件不能用标准I/O fopen函数打开，首先必须先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准I/O流与该描述符相结合。
  type参数指定对该I/O流的读写方式，ANSI C规定type参数可以有15种不同的值，它们分别如下:
  * r或rb: 为读而打开
  * w或wb: 使文件成为0长，或为写而创建
  * a或ab: 添加；在文件尾写而打开，或为写而创建
  * r+或r+b或rb+: 为读和写而打开
  * w+或w+b或wb+: 使文件长度为0，或为读和写而打开
  * a+或a+b或ab+: 为在文件末尾读和写而打开或创建。

  使用字符b作为type的一部分，使得标准I/O系统可以区分文本文件和二进制文件。因为Unix内核并不对这两种文件进行区分，所以在Unix系统环境下指定字符b作为type的一部分实际上并无作用。
  对于fdopen, type参数的意义稍有不同。因为该描述符已经被打开，所以fdopen为写而打开并不截短该文件。(例如，若该描述符原来是由open函数打开的，该文件那时已经存在，则其O_TRUNC标志将决定是否截短该文件。fdopen函数不能截短它为写而打开的任意文件。)另外，标准I/O添加方式也不能用于创建该文件(因为如若一个描述符引用一个文件，则该文件一定已经存在)。
  当用添加类型打开一文件后，则每次写都将数据写到文件的当前尾端处。如若有多个进程用标准I/O添加方式打开了同一个文件，那么来自每个进程的数据都将正确的写到文件中。
  
  当以读写方式打开一文件，具有下列限制:
  * 如果中间没有fflush, fseek, fsetpos或rewind，则在输出的后面不能直接跟随输入。
  * 如果中间没有fseek, fsetpos或rewind或者一个输出操作没有达到文件尾端，则在输入操作之后不能直接跟随输出。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/io_types.png)

  注意，在指定w或a类型创建一个新文件时，我们无法说明该文件的存取许可权位.POSIX.1要求以这种方式创建的文件具有下列存取许可权:
  S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
  
  除非流引用终端设备，否则按系统默认，它被打开时是全缓存的。若流引用终端设备，则该流是行缓存的。一旦打开了流，那么在对该流执行任何操作之前，如果希望，则可使用前节的setbuf, setvbuf改变缓存的类型。
  
  调用fclose关闭一个打开的流。int fclose(FILE *fp);
  在文件被关闭之前，刷新缓存中的数据。缓存中的输入数据被丢弃。如果标准I/O库已经为该流自动分配了一个缓存，则释放此缓存。
  
  当一个进程正常终止时(调用exit()或main函数返回)，则所有带未写缓存数据的标准I/O流都被刷新，所有打开的标准I/O流都被关闭。
  
### 5.6 读、写流
  一旦打开了流，则可在三种不同类型的非格式化I/O中进行选择，对其进行读、写操作。
  1. 每次一个字符的I/O，一次读或写一个字符，如果流是带缓存的，则标准I/O函数处理所有缓存。
  2. 每次一行的I/O, 使用fgets和fputs一次读或写一行。每行都以一个新行符终止。当调用fgets时，应说明能处理的最大行长。
  3. 直接I/O。 fread和fwrite函数支持这种类型的I/O, 每次I/O操作读或写某种数量的对象，而每个对象其具有指定的长度。这两个函数常用于从二进制文件中读或写一个结构。

#### 5.6.1 输入函数
  以下三个函数可用于一次读一个字符。
```
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
```
  函数getchar相当于getc(stdin). 前两个函数的区别是getc可被实现为宏，而fgetc则不能实现为宏。 这就意味着:
  * getc的参数不应当具有副作用的表达式
  * 因为fgetc一定是一个函数，所以可以得到其地址。这就允许将fgetc的地址作为一个参数传递给另一个函数。
  * 调用fgetc所需时间很可能长于调用getc，因为调用函数通常所需的时间长于调用宏。检验一下stdio.h头文件的大多实现，从中可见getc是一个宏，其编码具有较高的工作效率。
  这三个函数以unsigned char类型转换为int的方式返回下一个字符。 说明为不带符号的理由是，如果最高位为1也不会使返回值为负。要求整型返回值的理由是，这样就可以返回所有可能的字符值再加上一个易发生错误或到达文件尾端的指示值。在stdio.h中常数EOF被要求的是一个负值，其值经常是-1. 这就意味着不能将这三个函数的返回值存放在一个字符变量中，以后还要将这些函数的返回值与常量EOF相比较。
  注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值。为了区分这两种不同的情况，必须调用ferror或feof.
```
#include <stdio.h>
int ferror(FILE *fp);
int feof(FILE *fp);

void clearerr(FILE *fp);
```
  在大多数实现的FILE对象中，为每个流保持了两个标志:
  * 出错标志
  * 文件尾端标志。
  调用clearerr则清除这两个标志。

  从一个流读之后，可以调用ungetc将字符再送回流中。int ungetc(int c, FILE *fp);
  流回到流中的字符以后可从流中读出，单读出字符的顺序与送回的顺序相反。应当了解，虽然ANSI C允许支持任何数量的字符会送的实现，但是它要求任何一种实现都要支持一个字符的回送功能。
  回送的字符，不一定必须是上一次都到的字符。EOF不能回送。但是当已经到达文件尾端时，人可以回送一个字符。下次读将返回该字符，再次读则返回EOF. 之所以能这样做的原因是一次成功的ungetc调用回清除该流的文件结束指示。
  
  当正在读一个输入流，并进行各种形式的分字或分记号操作时，会经常用到回送字符操作。优势需要先看一看下一个字符，以决定如何处理当前字符。然后就需要方便地将刚查看的字符送回，以便下一次调用getc时返回该字符。如果标准I/O库不提供回送能力，就需要将该字符存放到一个我们自己的变量中，并设置一个标志以便判断在下一次需要一个字符时是调用getc，还是从我们自己的变量中取用。
  
#### 5.6.2 输出函数
  对应于上面所述的每个输入函数都有一个输出函数。
```
#include <stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
```
  与输入函数一样，putchar(c)等价于putc(c, stdout), putc可被实现为宏，而fputc则不能实现为宏。
  
### 5.7 每次一行I/O
  下面两个函数提供每次输入一行的功能。
```
#include <stdio.h>
char *fgets(char *buf, int n, FILE *fp);
char *gets(char *buf);
```
  这两个函数都指定了缓存地址，读入的行将送入其中。gets从标准输入读，而fgets则从指定的流读。
  
  对于fgets，必须指定缓存的长度n, 此函数一直读到下一个新行符为止，但是不超过n-1个字符，读入的字符被送入缓存。该缓存以null字符结尾。如若该行，包括最后一个新行符数超过n-1, 则只返回一个不完整的行，而且缓存总是以null字符结尾。对fgets的下一次调用会继续该行。
  gets是一个不推荐使用的函数。问题是调用者在使用gets时不能指定缓存的长度。这样就可能造成缓存越界，写到缓存之后的存储空间中，从而产生不可预料的结果。这种缺陷曾被利用，造成1988年因特网蠕虫事件。虽然ANSI C提供gets，但不要使用它。
  
  fputs, puts提供每次输出一行的功能。 函数fputs以一个null字符终止字符串写到指定的流，终止符null不写出。 注意，这并不一定是每次输出一行，因为它并不要求在null之前一定是新行符。通常，在null符之前是一个新行符，但并不要求总是如此。
  
  puts将一个以null符终止的字符串写到标准输出，终止符不写出。但是，puts然后又将一个新行符写到标准输出。
  
  puts并不像它所对应的gets那样不安全。但是我们还是应避免使用它，以免需要记住它在最后又加上了一个新行符。如果总是使用fgets和fputs，那么就会熟知在每行终止处我们必须自己加一个新行符。
  

### 5.8 标准I/O效率
  使用前面所述的函数，我们应该对标准I/O系统的效率有所了解。程序5.1类似于3.3, 它使用getc和putc将标准输入复制到标准输出。这两个函数可以实现为宏:
  
### 5.9 二进制I/O

### 5.10 定位流

### 5.11 格式化I/O

### 5.12 实现细节

### 5.13 临时文件

### 5.14 内存流

### 5.15 标准流可替换品

### 5.16 总结
