## 第五章 标准I/O类库

### 5.1 引言
  本章说明标准I/O库。 因为不仅在Unix而且在很多操作系统上都实现此库，所以它由ANSI C标准说明。标准I/O库处理很多细节，例如缓存分配，以及优化长度执行I/O等。这样使用户不必担心如何选择使用正确的块长度。标准I/O库是在系统调用基础上构造的，它便于用于使用，但是如果不较深入的了解库的操作，也会带来一些问题。

### 5.2 流和FILE对象
  在第三章中，所有I/O函数都是针对文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续读的I/O操作。而对于标准I/O库，它们的操作则是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相结合了。
  
  当打开一个流时，标准I/O函数fopen返回一个指向FILE对象的指针。该对象通常是一个结构，它包含了I/O库为管理该流所需要的所有信息:用于实际I/O的文件描述符，指向流缓存的指针，缓存的长度，当前在缓存中的字符数，出错标志等等。
  
  应用程序没有必要检验FILE对象。为了引用一个流，需要将FILE指针作为参数传递给每个标准I/O函数。在本书中，我们称指向FILE对象的指针为文件指针。
  
  在本章中，我们以Unix系统为例，说明标准I/O库。正如前述，此标准库已移除到除Unix以外的很多系统中。但是为了说明该类库实现的一些细节，我们选择Unix实现作为典型进行介绍。

### 5.3 标准输入、标准输出和标准出错
  对一个进程预先定义了三个流，它们自动地可为进程使用:标准输入流、标准输出流、标准出错流。在3.2节，我们曾用文件描述符STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO分别表示它们。
  这三个标准I/O流通过与定义文件指针stdin, stdout, stderr加以引用。这三个文件指针同样定义在stdio.h文件中。

### 5.4 缓冲区
  标准I/O提供缓冲地目的是尽可能减少使用read和write调用的数量。它也对每个I/O流自动地进行缓存管理，避免了应用程序需要考虑这一点所带来地麻烦。不幸的是，标准I/O库令人最感迷惑的也是它的缓存。
  
  标准I/O库提供了三种类型的缓存:
  1. 全缓存。 这种情况下， 当填满标准I/O缓存后才进行实际I/O操作。对于驻在磁盘上的文件通常是由标准I/O库实施全缓存的。 在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需要使用的缓存。<p>术语刷新flush说明标准I/O缓存的写操作。缓存可由标准I/O例程自动地刷新(当填满一个缓存时)，或者可以调用函数fflush刷新一个流。 值得引起注意地是在Unix中，刷新有两种意思。在标注I/O库方面，刷新意味着将缓存中地内容写到磁盘上(该缓存可以只是局部填写的). 在终端驱动程序方面，刷新表示丢弃已存放在缓存中的数据。</a>
  2. 行缓存。 在这种情况下，当在输入和输出中遇到新行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符(用标准I/O fputc函数)，但只有在写了一行之后才进行实际I/O操作。当流涉及一个终端时(例如标准输入和标准输出)，典型的使用行缓存。<p>对于行缓存有两个限制。第一个是:因为标准I/O库用来收集每一行的缓存长度是固定的，所以只要填满了缓存，那么即使还没有写一个新行符，也进行I/O操作。第二个是: 任何时候只要通过标准输入输出库要求从(a)一个不带缓存的流，或者(b)一个行缓存的流(它预先要求从内核得到数据)得到输入数据，那么就会造成刷新所有行缓存的输出流。 在(b)中带了一个在括号中的说明的理由是，所需的数据可能已经在该缓存中，它并不要求内核在需要该数据时才进行该操作。很明显，从不带缓存的一个流中进行输入((a))要求当时从内核得到数据。</p>
  3. 不带缓存。标准I/O库不对字符进行缓存。如果用标准I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。标准出错流stderr通常是不带缓存的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符。
  
  ANSI C要求下列缓存特征:
  1. 当且仅当标准输入和标准输出并不涉及交互作用设备时，它们才是全缓存的。
  2. 标准出错绝不会是全缓存的。
  
  但是，这并没有告诉我们如果标准输入和输出涉及交互作用设备时，它们是不带缓存的还是行缓存的，以及标准输出是不带缓存的，还是行缓存的。SVR4和4.3+BSD的系统默认使用下列类型的缓存:
  * 标准出错是不带缓存的
  * 如果涉及终端设备的其他流，则它们是行缓存的，否则是全缓存的。
  
  对任何一个给定的流，如果我们并不喜欢这些系统默认，则可以调用下列两个函数中的一个更改缓存类型:
```
#include <stdio.h>
void setbuf(FILE *fp, char *buf);
int setvbuf(FILE *fp, char *buf, int mode, size_t size);
```
  这些函数一定要在流已经被打开后调用,而且也应在对该流执行任何一个其他操作之前调用。
  可以使用setbuf函数打开或关闭缓存机制。为了带缓存进行I/O, 参数buf必须指向一个长度为BUFSIZE的缓存(该常数定义在stdio.h中)。通常在此之后该流就是全缓存的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓存的。为了关闭缓存，将buf设置为NULL.
  
  使用setvbuf，我们可以精确的说明所需的缓存类型。这是依靠mode参数实现的:
  * _IOFBF 全缓存
  * _IOLBF 行缓存
  * _IONBF 不带缓存
  
  如果指定一个不带缓存的流，则忽略buf和size参数。如果指定全缓存或行缓存，则buf和size可以选择地指定一个缓存以及长度。如果该流是带缓存的，而buf是NULL, 则标准I/O库将自动地为流分配适当长度地缓存。适当长度指地是由struct结构中地成员st_blksize所指定的值。如果系统不能为该流决定此值(例如若此流涉及一个设备或一个管道)，则分配长度为BUFSIZE的缓存。
  ![](https://github.com/walkerqiao/walkman/tree/master/images/APUE/setbuf_setvbuf.png)
  

### 5.5 打开流

### 5.6 读、写流

### 5.7 每次一行I/O

### 5.8 标准I/O效率

### 5.9 二进制I/O

### 5.10 定位流

### 5.11 格式化I/O

### 5.12 实现细节

### 5.13 临时文件

### 5.14 内存流

### 5.15 标准流可替换品

### 5.16 总结
