AIO详解
------

  Linux中最常用的输入/输出(I/O)模型是同步I/O. 在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是一个很好的解决方案，因为调用应用程序在等待I/O请求完成时不需要使用任何CPU. 但是在某些情况下，I/O请求可能需要与其他进程产生交叠。可移植操作系统接口(POSIX)异步I/O(AIO)应用程序接口就提供了这种功能。在本文中，我们将对这个API概要进行介绍，并来了解一下如何使用它。
  
### AIO简介
  Linux异步I/O是Linux内核中提供的一个相当新的增强。它是2.6版本内核的一个标准特性，但是我们在2.4版本内核的补丁中也可以找到它。AIO背后的基本思想是允许进程发起很多I/O操作，而不用阻塞或等待任何操作完成。稍后或在接收到I/O操作完成的通知时，进程就可以检索I/O操作的结果。
  
### I/O模型
  在深入介绍AIO API之前，让我们先来探索一下Linux上可以使用的不同I/O模型。这并不是一个详尽的介绍，但是我们将试图介绍最常用的一些模型来解释它们与异步I/O之间的区别。下图给出了同步和异步模型，以及阻塞和非阻塞模型。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/io_models.png)
  
  每个I/O模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将要简要对其一一进行介绍。
  
### 同步阻塞I/O
  最常用的一个模型是同步阻塞I/O模型。在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止(数据传输完成或发生错误)。调用应用程序处于一种不再消费CPU而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。
  
  图2给出了传统的阻塞I/O模型，这也是目前应用程序中最为常用的一种模型。其行为非常容易理解，其用法对于典型的应用程序来说都非常有效。在调用read系统调用后，应用程序会阻塞并对内核进行上下文切换。然后会触发读操作，当响应返回时(从我们正在从中读取的设备中返回), 数据就被移动到用户空间的缓冲区中。然后应用程序就会解除阻塞(read调用返回).
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/sync_io_model.png)
  
  从应用程序的角度来说，read调用会延续很长时间。实际上，在内核执行读操作和其他工作时，应用程序的确会被阻塞。
  
### 同步非阻塞I/O
  同步阻塞I/O的一种效率稍低的变种是同步非阻塞I/O。在这种模型中，设备是以无阻塞的形式打开的。这意味着I/O操作不会立即完成，read操作可能会返回一个错误代码，说明这个命令不能立即满足(EAGAIN或EWOULDBLOCK), 如图3:
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/sync_nonblock_io_model.png)
  
  非阻塞的实现是I/O命令可能并不会立即满足，需要应用程序调用许多次来等待操作完成。这可能效率不高，因为在很多情况下，当内核执行这个命令时，应用程序必须要进行忙碌等待，直到数据可用为止，或者试图执行其他工作。正如图3所示的一样，这个方法可以引入I/O操作的延时，因为数据在内核中变为可用到用户调用read返回数据之间存在一定的间隔，这回导致整体数据吞吐量的降低。
  
### 异步阻塞I/O
  另外一个阻塞解决方案是带有阻塞通知的非阻塞I/O. 在这种模型中，配置的是非阻塞I/O,然后使用阻塞select系统调用来确定一个I/O描述符何时有操作。使select调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。对于每隔提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/async_block_io_model_select.png)
  
  select调用的主要问题是它的效率不是很高。尽管这是异步通知使用的一种方便模型，但是对于高性能的I/O操作来说不建议使用。
  
### 异步非阻塞I/O(AIO)
  最后，异步非阻塞I/O模型是一种处理与I/O重叠进行的模型。读请求会立即返回，说明read请求已经成功发起。在后台完成读操作时，应用程序然后会执行其他处理操作。当read的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次I/O处理过程。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/async_nonblock_io_model_aio.png)
  
  在一个进程中为了执行多个I/O请求而对计算操作和I/O处理进行重叠处理的能力利用了处理速度与I/O速度之间的差异。当一个或多个I/O请求挂起时，CPU可以执行其他任务；或者更为常见的是，在发起其他I/O的同时对已经完成的I/O进行操作。
  
  下一节将深入介绍这种模型，探索这种模型使用的API，然后展示几个命令。
  
  
