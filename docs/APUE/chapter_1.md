# 第一章 Unix System Overview(Unix系统概述)
## 1.1 简介
  所有的操作系统都向它运行的程序提供服务。典型的服务包括执行新程序、打开文件、读取文件、分配内存区域、获取当前时间等等。 本书着重描述各种Unix操作系统所提供的服务。
  
  以严格的步进方式、不超前引用尚未说明过的术语的方式来说明UNIX几乎是不可能的(可能是令人厌恶的)。 本章从程序设计人员的角度快速浏览UNIX, 并对书中引用的一些术语和概念进行简要的说明并给出实例。在以后各章种，将对这些概念做更详细的说明。本章也对不熟悉Unix的程序设计人员简要介绍了Unix提供的各种服务。
  
## 1.2 Unix架构
  严格意义上说，操作系统可以被定义为控制计算机硬件资源的软件，并能为程序运行提供环境。一般而言，我们称这种软件叫做内核(kernel)， 因为它相对比较小、而且位于环境的核心位置。 下图展示了Unix系统架构:
  ![Unix架构图](https://github.com/walkerqiao/walkman/blob/master/images/APUE/unix_architecture.png)
  
  内核接口层就是所谓的系统调用软件层(system calls)(上图中的阴影部分). 公共功能库构建于系统调用接口层之上， 但是应用程序可以使用自由使用系统调用和公共类库。(我们会在后面的1.11节介绍更多这方面的。) Shell一种特殊的应用，提供了运行其他应用程序的接口。
  
  从广义上来讲，操作系统是由内核以及所有其他使得计算机有用并有个性的软件组成。这些其他应用程序包括系统工具、应用程序、shells、公共函数等等。
  
  例如，Linux是GNU操作系统使用的内核。 有些人称它为GNU/Linux操作系统， 但是更多普遍称为简单的Linux。 虽然这种叫法在严格意义上来说是不对的， 不标准的， 给术语操作系统双重意义。(但是这样优势是更加简洁。)

## 1.3 登录
  登录Unix系统时，先键入登录名，然后键入口令。系统在其口令文件，通常是/etc/passwd文件中查看登录名。口令文件中的登录项由7个以冒号分割的字段组成: 登录名、加密口令、数字用户ID、数字组ID、注视字段、起始目录、以及shell程序。
  
  很多比较新的系统已将加密口令移到另外一个文件中。第六章讲说明这种文件以及存取它们的函数。
  
  一旦登入，系统先显示一些典型的系统信息，然后就可以向shell程序键入命令。shell是一个命令行解释器，它读取用户输入，然后执行命令，用户通常用终端，优势则通过文件(shell脚本)向shell进行输入。 常用的shell有:
  * Bourne Shell, /bin/sh
  * C Shell, /bin/csh
  * KornShell, /bin/ksh
  
  系统从口令文件中登录项的最后一个字段中了解到应该执行哪一个shell.

  自V7以来，Bourne Shell得到广泛应用，几乎每一个现有的Unix系统都提供Bourne Shell. C Shell是在伯克利开发的，所有BSD版本都提供这种shell. 另外AT&T系统V/386 R3.2和SVR4也提供C Shell. KornShell是Bourne Shell的后继者，它由SVR4提供。 KornShell在大多数Unix系统上运行，但在SVR4之前，通常它需要另行购买，所以没有其他两种shell流行。

## 1.4 文件和目录

### 文件系统
  Unix文件系统是目录和文件的一种层次安排，目录的起点称为根(root)，其名字是一个字符'/'.
  
  目录(directory)是一个包含目录项的文件，在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息。文件属性是：文件类型、文件长度、文件所有者、文件的许可权(例如，其他用户能否访问该文件)、文件的最后修改时间等。 stat和fstat函数返回一个包含所有文件属性的信息结构。
### 文件名
  目录中的各个名字称为文件名(filename).不能出现在文件名中的字符只有两个'/', 和空操作符(null).
### 路径名
  0个或多个以斜线分割的文件名序列(可以任选地以斜线开头)构成路径名(pathname), 以斜线开头的路径名称为绝对路径名(absolute pathname), 否则称为相对路径(relative pathname).
  
  实例，列出一个目录中所有文件的名字，下面程序是ls(1)命令的主要实现部分:
```
#include "apue.h"

int main(int argc, char **argv)
{
    DIR *dp;
    struct dirent *dirp;

    if(argc != 2)
        err_quit("a single argument (the directory name) is required");

    if((dp = opendir(argv[1])) == NULL)
        err_sys("can't open %s", argv[1]);

    while((dirp = readdir(dp)) != NULL)
        printf("%s\n", dirp->d_name);

    closedir(dp);
    exit(0);
}
```
  其中apue.h为公共头，包含了公共的库函数定义，以及必要的头文件引入。 这里的DIR, dirent都是需要引入`include <dirent.h>`. 
  
  ls(1)这种表示方法是Unix的惯用方法，用以引用Unix手册集中的一个特定项。它引用第一部分中的ls项。各部分通常用1-8表示，在每个部分中的各项则按字母顺序排列。假定你有一份所使用的Unix系统的手册。
  
```
  早期的Unix系统把8个部分都集中在一本手册中，现在的趋势是把这些部分分别安排在不同的手册中:有用户专用手册、程序员专用手册、
  系统管理员专用手册等。
  
  某些Unix系统把一个给定部分中的手册页又用一个大写字母进行分成若干小部分，例如， 
  AT&T(1990e)中的所有标准I/O函数都被指明在3S部分中，例如fopen(3S).
  
  某些Unix系统，例如以Xenix为基础的系统，不是采用数字将手册分成若干部分，而是用C表示命令(第一部分)，S表示服务(通常是第2、3部分)等等。
```

  如果你有联机手册，则可用下面的命令查看ls命令手册页: `man 1 ls`
  
  上面的程序只打印目录中各个文件的名字，不显示其他信息。
  
  

### 工作目录
  每个进程都有一个工作目录(working directory,有时称为当前工作目录). 所有相对路径名都从工作目录开始解释。进程可以用chdir函数更改其工作目录。
### 起始目录
  登录时，工作目录设置为起始目录(home directory),该起始目录从口令文件中的登录项中取得。

## 1.5 输入输出
### 文件描述符
  文件描述符是一个小的非负整数，内核用以标识一个特定进程正在存访的文件。当内核打开一个现存文件或创建一个新文件时，他就返回一个文件描述符。 当读、写文件时，就可使用它。
  
### 标准输入、标准输出和标准出错
  按惯例，每当运行一个新程序时，所有的shell都为其打开三个文件描述符:标准输入、标准输出以及标准出错。 如果像简单命令ls那样没有做什么特殊处理，则这三个描述副都连向终端。 大多数shell都提供一种方法，使任何一个或所有这三个描述符都能重新定向到某一个文件: `ls > file.list`
  
  执行ls命令，其标准输出重新定向到名为file.list的文件上。
  
### 不用缓存的I/O
  函数open, read, write, lseek以及close提供了不用缓存的I/O.这些函数都用文件描述符进行工作。
```
#include "apue.h"

#define BUFFSIZE 8129

int main(void)
{
    int n;
    char buf[BUFFSIZE];

    while((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
        if(write(STDOUT_FILENO, buf, n) != n)
            err_sys("write error");

    if(n < 0)
        err_sys("read error");

    exit(0);
}
```
  编译`gcc copy.c -o copy...`, 执行命令`ls -la . | ./copy > data`则ls-la的输出变为./copy的标准输入，继而被作为标准输出到data文件中。
  
  上面代码中read, write以及STDIN_FILENO, STDOUT_FILENO都是在unistd.h中定义。 这里赞不过多介绍。
```
这里穿插介绍下apue项目源代码结构：
apue +---------- lib
_    |            |------- error.c
_    |            |------- xx.c             ==> libapue.a
_    |            |------- xxlib.c
_    |            |------- makefile
_    |---------- include
_    |             |------ apue.h
_    |             |------ error.h
_    |---------- subproject
_    |             |----------  program1.c         => program1
_    |             |----------  makefile
_    |---------- subproject
_    |---------- makefile
_    |---------- make.defines.{osname}    // 包含特定os定义的make变量定义
_    |---------- make.libapue.inc         // 编译libapue的包含文件
_    |---------- systype.sh               // 获取os名称的脚本
```
  在apue根目录有一个makefile， 直接调用make可对所有项目进行编译，包括类库libapue.a。 而每个目录下面都有单独的makefile,用于编译每个子项目下面的所有程序。 这里每个子项目的程序列表都定义在makefile中。
  
  需要注意一点， 如果子项目修改后需要编译，同时需要确保libapue.a是最新的，从子项目里边无法确认libapue.a是否为最新。 makefile书写的问题吧。 暂时不做修改。
  
  对每个程序而言，只要libapue.a没有改动，直接在自己的项目子目录里边添加程序名，然后make就可完成编译。
  
### 标准I/O
  标准I/O函数提供了一种对不用缓存的I/O函数的带缓存界面。使用标准I/O可无需担心如何选区最佳的缓存长度，例如上面程序的BUFFSIZE常数。 另一个使用标准I/O函数的优点与处理输入行有关(常常发生在Unix的应用中)。 例如，fgets函数读一完整的行，而另一方面，read函数读取指定字节数。
  
  我们最熟悉的标准I/O函数是printf. 在调用printf的程序中，总是包括stdio.h,因为此头文件包含了所有标准I/O的函数的原型。
```
#include "apue.h"

int main(void)
{
    int c;
    while((c = getc(stdin)) != EOF)
        if(putc(c, stdout) == EOF)
            err_sys("output error");


    if(ferror(stdin))
        err_sys("input error");

    exit(0);
}
```
  函数getc一次读取1字符，然后putc将此字符写到标准输出。都到输入的最后一个字节时，getc返回常数EOF. 标准输入、输出常数stdin, stdout定义在头文件stdio.h中，它们分别表示标准输入和标准输出。

## 1.6 程序和进程
  程序时存放在磁盘文件中的可执行文件。使用6个exec函数中的一个由内核将程序读入存储器，并使其执行。

### 进程和进程ID
  程序的执行实例被称为进程。每个Unix进程都一定由一个唯一的数字标识符，称为进程ID, 进程ID总是一个非负整数。
  
```
#include "apue.h"
int main(void)
{
  printf("hello world from process ID %d\n", getpid());
  exit(0);
}
```
### 进程控制
  有三个用于进程控制的主要函数: fork, exec, waitpid(exec有六种变体，但经常把它们统称为exec函数)
```
#include "apue.h"
#include <sys/types.h>
#include <sys/wait.h>

int main(void)
{
  char buf[MAXLINE];
  pid_t pid;
  int status;

  printf("%% "); /* 要打印%, 需要使用%% */

  while(fgets(buf, MAXLINE, stdin) != NULL) {
      buf[strlen(buf) - 1] = 0;   /* replace new line with null */

      if((pid = fork()) < 0)
          err_sys("fork error");

      else if(pid == 0) { /* child process */
          execlp(buf, buf, (char *) 0); 
          err_ret("couldn't execute: %s", buf);
          exit(127);
      }   

      if((pid = waitpid(pid, &status, 0)) < 0)
          err_sys("waitpid error");

      printf("%% "); 
  }   
  exit(0);
}
```
  编译并运行代码如下
```
bogon:first apple$ ./proc_ctrl 
% ls
copy			copy_getc_putc		data			lsdir.c			proc_ctrl		procid
copy.c			copy_getc_putc.c	lsdir			makefile		proc_ctrl.c		procid.c
% pwd
/Users/apple/development/github/walkcapp/apue/first
% bogon:first apple$ 
```
  Unix进程控制功能可以是一个较简单的程序说明，该程序从标准输入读取命令，然后执行这些命令。这是一个类似于shell程序的基本实施部分。在这30行的程序中有许多功能需要思考:
  * 用标准I/O函数fgets从标准输入一次读一行，当键入文件结束字符(通常是Ctrl-D)作为行的第一个字符时，fgets返回一个null指针，yushi循环终止，进程也就终止了。
  * 因为fgets返回的每一行都以新行符号终止，后随一个null字符，故而用标准函数strlen计算此字符串的长度，然后用一个null字节替换新行符。 这一操作的目的是因为execlp函数要求的是以null结束的操作，而不是以新航符结束的参数。
  * 调用fork创建一个新进程。新进程是调用进程的复制品，故而称调用进程为父进程，新建的进程为子进程。fork对父进程返回新进程的非负进程ID, 对子进程则返回0. 因为fork创建一个新进程，所以说他被调用一次(由父进程)，但返回两次(在父进程中和在子进程中)。
  * 在子进程中国年，调用execlp以执行从标准输入读入的命令。这就用新的程序文件替换了进程。fork和跟随其后的exec的组合是某些操作系统所称的产生一个新进程。在Unix中，这两个部分分成两个函数。
  * 子进程调用execlp执行新程序文件，而父进程希望等待子进程终止，这一要求由调用waitpid实现，其参数指定要等待的进程。waitpid函数也返回子进程的终止状态。在此简单程序中，没有使用这个终止状态status. 如有需要，可用此值精确地确定子进程是如何终止的。
  * 该程序的最主要限制是不能向执行的命令传递参数。为了传递参数，先要分析输入行，然后用某种约定把参数分开，然后将分割后的各个参数传递给execlp函数。尽管如此，此程序仍可用来说明unix的进程控制功能。
  
  以_t结尾的这些数据类型被称为原始系统数据类型。通常在头文件<sys/types.h>中定义(unistd.h已经包含该头文件)。

## 1.7 错误处理
  当Unix函数出错时，往常返回一个负值，而且整形变量errno通常设置为具有特定信息的一个值。例如，open函数如成功执行则返回一个非负文件描述符，如出错则返回-1. 在open出错时，由大约15中不同的errno值(文件不存在，许可权问题等)。某些函数并不返回负值而是使用另一种约定。例如，返回一个值指向对象的指针的大多数函数，在出错时，将返回一个null指针。
  
  文件<errno.h>中国年定义了变量errno以及可以赋予它的各种函数。这些常量都以E开头，另外，Unix手册第二部分的第一页,intro(2)列出了所有的这些出错常量。 例如，当errno等于常量EACCESS，这表示产生了权限问题(例如，没有打开所要求的文件权限)。POSIX定义errno为`extern int errno`
  
  对于errno应当知道两条规则。
  1. 如果没有出错，则其值不会被一个例程清除。因此，仅当函数的返回值指明出错时，才检验其值。
  2. 任一函数都不会将errno值设置为0， 在<errno.h>中定义的所有常量都不为0.
  
  C标准定义了两个函数，它们帮助打印出错信息: /usr/include/sys/errno.h
```
#include <string.h>
char *strerror(int errnum)
void perror(const char msg)
```
  strerror将errno映射为一个出错信息字符串，并且返回此字符串的指针。
  perror函数在标准出错上产生一条出错信息(基于errno的当前值)，然后返回。
  
## 1.8 用户识别
### 用户ID
  口令文件登录项中的用户ID(user ID)是个数值，它向系统标识各个不同的用户。系统管理员在确定一个用户的登录名的同时，确定其用户ID. 用户不能更改其用户ID, 通常每个用户有一个唯一的用户ID, 下面将介绍内核如何使用用户ID以及检验该用户是否有执行某些操作的适当许可权。
  
  用户ID为0的用户为根(root)或超级用户(superuser). 在口令文件中，通常有一个登录项，其登录名为root, 我们称这种用户的特权为超级用户特权。
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

int main(int argc, char **argv)
{
    printf("uid = %d, gid = %d\n", getuid(), getgid());
    exit(0);
}
```
  上述getuid, getgid需要引入unistd.h.
  
### 组ID
  口令文件登录项也包括用户的组ID,它也是一个数值。 组ID也是由系统管理员在确定用户登录名时分配的。 一般来说，在口令文件中有多个记录项具有相同的组ID. 在Unix下，组被用于将若干用户集合到课题或部门中去。这种机制允许同组的各个成员之间共享资源(如文件)。 组文件将组名映射为数字组ID,通常是/etc/group.
  
  对于许可权使用数值用户ID和数值组ID是历史上形成的。系统中每个文件的目录项包含该文件所有者的用户ID和组ID. 在目录项中存放这两个值只需要4个字节(假定每个都以双字节的整数型值存放。)如果使用8字节的登录名和8字节的组名，则需要较多的磁盘空间。 但是对于用户而言，使用名字必使用数值更方便，所以口令文件包含了登录名和用户ID之间的映射关系，而组文件则包含了组名和组ID之间的映射关系。例如Unix ls -l命令使用口令文件将数值用户ID映射为登录名，从而打印文件所有者的登录名。
  
### 添加组ID
  除了在口令文件中对一个登录名指定一个组ID外，某些Unix版本还允许一个用户属于另外一些组。
  
## 1.9 信号
  信息是通知进程已经发生某种条件的一种技术。 例如，若某一进程执行除法操作，其除数为0，则将名为SIGFPE的信号发送给该进程。进程如何处理信号有三种选择:
  * 忽略该信号
  * 按系统默认方式处理
  * 提供一个函数，信号发生时则调用该函数。

  
## 1.10 时间值
  长期以来，Unix系统一致使用两种不同的时间值:
  1. 日历时间。该值从1970年1月1日00:00:00以来国际标准时间所经历的秒数累计值。这些时间值可用于记录文件最近一次的修改时间等。
  2. 进程时间。 这也被称为CPU时间，用以度量进程使用的中央处理机资源。进程时间以时钟嘀嗒计算，多年来，每秒钟取为50，60或100个嘀嗒。系统基本数据类型clock_t保存这种时间值。另外POSIX定义常数CLK_TCK, 用其说明每秒嘀嗒数。(常数CLK_TCK现在已经不使用。 后面可使用sysconf函数得到每秒时钟嘀嗒数)
  
  当度量一个进程的执行时间时，Unix系统使用三个进程时间值:
  1. 时钟时间
  2. 用户CPU时间
  3. 系统CPU时间
  
  时钟时间又称为墙上时钟时间(wall clock time). 它是进程运行的时间总量，其值与系统中同时运行的进程数有关。在我们报告时钟时间时，都是在系统中没有其他活动时进行度量的。

  用户CPU时间时执行用户指令所用的时间量。系统CPU时间是为该进程执行内核所经历的时间。例如，只要一个进程执行一个系统服务，例如read或write， 则在内核内执行该服务所花费的时间就计入该进程的系统CPU时间。用户CPU时间和系统CPU时间的和常被称为CPU时间。
  
  要取得任一进程的时钟时间、用户时间和系统时间很容易-- 只要执行time(1)，其参数是要度量其执行时间的命令，例如:
```
bogon:first apple$ time ls
...

real	0m0.005s
user	0m0.002s
sys	0m0.003s
```
## 1.11 系统调用和类库
  所有操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX都提供经良好定义的有限数目的入口点，经过这些入口点进入内核，这些入口点被称为系统调用(system call). 系统调用是不能更改的一种Unix特征。Unix第7版提供了50个系统调用，4.3+BSD提供了约110个，而SVR4则提供了约120个。
  
  系统调用界面总是在Unix程序员手册的第二部分中说明。其定义也包括在C语言中。这雨很多早期的操作系统不同，这些系统按传统方式在机器的汇编语言中定义内核入口点。
  
  Unix所使用的技术是为每个系统调用在标准C库中设置一个具有同样名字的函数。用户进程用标准C调用序列来调用这些函数，然后，函数又用系统所需要的技术调用相应的内核服务，例如函数可讲一个或多个C参数传入通用寄存器，然后执行某个产生软终端进入内核的机器指令。 从应用角度考虑，可将系统调用视作C函数。
  
  Unix程序员手册的第三部分定义了程序员可以使用的通用函数。虽然这些函数可能会调用一个或多个内核的系统调用，但是它们并不是内核的入口点。例如，printf函数会调用write系统调用以进行输出操作，但函数strcpy和atoi并不使用任何系统调用。
  
  从执行者的角度来看，系统调用和库函数之间有重大区别，但从用户角度来看，其区别并不非常重要。在本书中系统调用和库函数都以C函数的形式出现，两者都对应用提供服务，但是，我们应当理解，如果希望的化，我们可以替换库函数，但是通常却不能替换系统调用。
  
  以存储器分配函数malloc为例。有多种方法可以进行存储器分配及其相关的误用区收集操作(最佳适应、首次适应等)，并不存在对所有程序都最佳的一种技术。Unix系统调用中处理存储器分配的是sbrk(2), 他不是一个通用的存储器管理器，它增加或减少指定字节数的进程地址空间。如何管理该地址空间却取决于进程。存储器分配函数malloc(3)实现一种特定类型的分配。如果我们不喜欢器操作方式，则可以定义自己的malloc函数，它可能将使用sbrk系统调用。事实上，很多软件包，它们自己的存储器分配算法，但仍使用sbrk系统调用。
  ![malloc and sbrk](https://github.com/walkerqiao/walkman/blob/master/images/malloc_sbrk.png)
  
  从上图可看到，两者职责不同，相互分开，内核中的系统调用分配另外一块空间给进程，而库函数malloc负责管理这一空间。
  
  另一个可说明系统调用和库函数之间差别的例子是，Unix提供决定当前时间和日期时间的界面。某些操作系统提供一个系统调用以返回时间，而另一个则返回日期。任何特殊的处理，例如正常时间机制和夏时制之间的转换，由内核处理或要求人为干预。Unix则不同，它只提供一条系统调用，该系统调用返回国际标准时间1970年1月1日零点以来所经过的秒数。对该值的任何解释，例如将其变成人们可读的，使用本地时区的时间和日期，都留给用户进程运行。在标准C库中，提供了若干例程以外处理大多数情况。这些库函数处理各种细节，例如各种夏时制算法。
  
  应用程序可以调用系统调用或库函数，而很多库函数则会调用系统调用。
  ![sys lib vs sys call](https://github.com/walkerqiao/walkman/blob/master/images/syslib_vs_syscall.png)
  
  系统调用和库函数之间的另一个差别是:系统调用通常提供一种最小界面，而库函数通常提供比较复杂的功能。 我们从sbrk系统调用和malloc库函数之间的差别可以看到这一点。
  
## 1.12 总结
