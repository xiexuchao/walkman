## 第十章 信号

### 10.1 引言
  信号是软件中断。很多比较重要的应用程序都需要处理信号。信号提供了一种处理异步事件的方法:终端用户键入中断键，则会通过信号机构停止一个程序。
  
  Unix的早期版本，就已经有信号机构，但是这些系统，例如V7所提供的信号模型并不可靠。信号可能会丢失，而且在执行临界区代码时，进程很难关闭所选择的信号。4.3BSD和SVR3对信号模型都做了更改，增加了可靠信号机制。但是这两种更改之间并不兼容。幸运的是POSIX.1对可靠信号例程进行了标准化，这正是本章所说明的。
  
  本章先对信号机制进行综述，并说明每种信号的一般用法。然后分析早期实现的问题。在分析存在的问题之后再说明解决这些问题的方法，这样有助于加深对改进机制的理解。

### 10.2 信号概念
  首先，每隔信号都有一个名字。这些名字都是以三个字符SIG开头。例如，SIGABRT是夭折信号，当进程调用abort函数时产生这种信号。SIGALRM是闹钟信号，当由alarm函数设置的事件已经超过后产生此信号。V7有15种不同的信号，SVR4和4.3+BSD均有31种不同信号。
  
  在头文件<signal.h>中，这些信号都被定义为正整数(信号编码)。没有一个信号其编号为0. 在10.9会看到kill函数，对信号编号0有特殊的应用。POSIX.1将此种信号编号值称为空信号。
  
  很多情况可以产生一个信号。
  * 当用户按某些终端键时，产生信号。在终端上按DELETE键通常产生中断信号(SIGINT).这是停止一个已时区控制程序的方法。
  * 硬件异常产生信号:除数为0、无效的存储访问等等。这些条件通常由硬件检测到，并将其通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无效存储访问的进程产生一个SIGSEGV.
  * 进程用kill(2)函数可以将信号发送给另一个进程或进程组。自然，有些限制:接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。
  * 用户可用kill(1)命令将信号发送给其他进程。此程序是kill函数的界面。常用此命令终止一个失控的后台进程。
  * 当检测到某种软件条件已经发生，并将其通知有关进程时也产生信号。这里并不是指硬件产生条件(如被0除)，而是软件条件。例如SIGURG(在网络连接上传来非规定波特率的数据)、GIGPIPE(在管道的读进程已终止后一个进程写此管道)、以及SIGALRM(进程所设置的闹钟时间已经超时)。
  信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能指示测试一个变量(例如errno)来判断是否发生了一个信号，而是必须告诉内核"在此信号发生时，请执行下列操作"。
  可以要求系统在某个信号出现时按照下列三种方式中的一种进行操作:
  1. 忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却不能被忽略。它们是:SIGKILL和SIGSTOP. 这两种信号不能被忽略的原因是:它们向超级用户提供一种使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号(例如非法存储访问或除以0)，则进程的行为是未定义的。
  2. 捕捉信号。 为了做到这一点要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。例如，若编写一个命令解释器，当用户用键盘产生中断信号时，很可能希望返回到程序的主循环，终止系统正在为该用户执行的命令。如果捕获到SIGCHLD信号，则标识子进程已经终止，所以此信号的捕捉函数可以调用waitpid以取得该子进程的进程ID以及它的终止状态。又例如，如果进程创建了临时文件，那么可能要为SIGTERM信号编写一个信号捕捉函数以清楚临时文件(kill命令传送的系统默认信号时终止信号)。
  3. 执行系统默认动作。 对大多数信号系统的默认行为是终止该进程。
  
  表10-1列出所有信号的名字，哪些系统支持此信号以及对信号的系统默认动作。在POSIX.1列中，标识要求此种信号。job标识这是作业控制信号(仅当支持作业控制时，才要求此种信号)。
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/unix_signal1.png)
  ![](https://github.com/walkerqiao/walkman/blob/master/images/APUE/unix_signal2.png)

  在系统默认动作列，终止w/core表示在进程当前工作目录的core文件中国年复制了该进程的存储图像(该文件名为core,由此可以看出这种功能很久之前就是Unix功能的一部分)。大多数Unix调试程序都使用core文件以检查进程在终止时的状态。在下列条件下不产生core文件:
  1. 进程是set-user-ID，并且当前用户并非程序文件的所有者。
  2. 进程是set-group-ID, 而且当前用户并非该程序文件的所有者。
  3. 用户没有写当前工作目录的许可权
  4. 文件太大。
  core文件的许可权(假定该文件在此之前并不存在)通常是用户读/写，组读和其他读。

  下面比较详细地说明这些信号:
  * SIGABRT: 调用abort函数时产生此信号。进程异常终止。
  * SIGALRM: 超过用alarm函数设置地时间时产生此信号。若由setitimer(2)函数设置的间隔时间已经过时，那么也产生此信号。
  * SIGBUS: 指示一个实现定义的硬件故障。
  * SIGCHLD: 在一个进程终止或停止时，SIGCHLD信号被送给其父进程。按系统默认，将忽略此信号。如果父进程希望了解其子进程的这种状态改变，则应捕捉此信号。信号捕捉函数中通常要调用wait函数以取得子进程ID和其终止状态。
  * SIGCONT: 此作业控制信号送给需要继续运行的处于停止状态的进程。如果接收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行，否则默认动作是忽略该动作。例如vi编辑程序在捕捉到此信号后，重新绘制终端屏幕。
  * SIGEMT: 指示一个实现定义的硬件故障。
  * SIGFPE: 此信号表示一个算术运算异常，例如除以0，浮点溢出等。
  * SIGHUP: 如果终端界面检测到一个连接断开，则将此信号送给该终端相关的控制进程(对话期首进程)。此信号被送给session结构中的s_leader字段所指向的进程。金珰终端的CLOCAL标志没有设置时，在上述条件下才产生此信号。(如果所连接的终端是本地的，才设置该终端的CLOCAL标志。它告诉终端驱动程序忽略所有调制解调器的状态行。)注意，接到此信号的对话期首进程可能在后台。如果对话期前进程终止，则也产生此信号。这种情况下，此信号送给前台进程组中的每个进程。通常用此信号通知精灵进程以再读它们的配置文件。选用SIGHUP的理由是，因为一个精灵进程不会由一个控制终端，而且通常决不会接受这种信号。
  * SIGILL: 此信号指示进程已执行一条非法硬件指令。
  * SIGINFO: 这是一种4.3+BSD信号，当用户按状态键时，终端驱动程序产生此信号并送至前台进程组中的每一个进程。 此信号通常造成在终端上显示前台进程组中各进程的状态信息。
  * SIGINT: 当用户按中断键(DELETE或Ctrl-C)时，中断驱动程序产生此信号并送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它在屏幕上产生大量不需要的输出时，常用此信号终止它。
  * SIGIO: 此信号指示一个异步I/O事件。
  * SIGIOT: 这指示一个实现定义的硬件故障。
  * SIGKILL: 这是两个不能被捕捉或忽略的信号之一。它向系统管理员提供了一种可以杀死任一进程的可靠方法。
  * SIGPIPE: 如果在读进程已经终止时写管道，则产生此信号。当套接口的一端已经终止时，若进程写该套接口也产生此信号。
  * SIGPOLL: 这是一种SVR4信号，当在一个可轮询设备上发生以特定事件时产生此信号。后面会说明poll和此信号。它与4.3+BSD的SIGIO和SIGURG信号接近。
  * SIGPROF: 当setitimer(2)函数设置的梗概统计间隔事件已经超过时产生此信号。
  * SIGPWR: 这是一种SVR4信号，它依赖于系统。它主要用于具有不间断电源(UPS)的系统上。如果电源失效，则UPS起作用，而且通常软件会接到通知。在这种情况下，系统依靠蓄电池电源继续运行，所以无需做任何处理。但是如果蓄电池也将不能支持工作，则软件通常会再次接到通知，此时，它在15～30秒内使系统个部分都停止运行。此时应当传递SIGPWR信号。在大多数系统中使接到蓄电池电压过低的进程将信号SIGPWR发送给init进程，然后由init处理停机操作。很多系统V的init实现在inittab文件中提供了两个记录项用于此种目的。powerfail以及powerwait. 
  * SIGQUIT: 当用户在终端上按退出键(一般采用`Ctrl+\`)时，产生此信号，并送至前台进程组中的所有进程。此信号不仅终止前台进程组(如SIGINT所做的那样)，同时产生一个core文件。
  * SIGSTOP: 这是一个作业控制信号，它停止一个进程。它类似于交互停止信号(SIGTSTP),但是SIGSTOP不能被捕获或忽略。
  * SIGSYS: 指示一个无效的系统调用。由于某种未知原因，进程执行了一跳系统调用指令，但其指示系统调用类型的参数确实无效的。
  * SIGTERM: 这是由kill(1)命令发送的系统默认终止信号。
  * SIGTRAP: 指示一个实现定义的硬件故障。
  * SIGTSTP: 交互停止信号，当用户在终端上按挂起键(一般采用Ctrl-Z)时，终端驱动程序产生此信号。
  * SIGTTIN: 当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。在下列例外情形下不产生此信号，此时读操作出错，errno设置为EIO: a)读进程忽略或阻止此信号 b)读进程所属的进程组是孤儿进程组。
  * SIGTTOU: 当一个后台进程组进程试图写其控制终端时产生此信号。与上面所述的SIGTTIN信号不同，一个进程可以选择为允许后台进程写控制终端。
  * SIGURG: 此信号通知进程已经发生一个紧急情况。
  * SIGUSR1: 这是一个用户自定义信号，可用于应用程序
  * SIGUSR2: 这是一个用户自定义信号，可用于应用程序
  * SIGVTALRM:
  * sigwinch
  * SIGXCPU
  * SIGXFSZ


### 10.3 signal函数
  Unix信号机制最简单的界面是signal函数:
```
#include <signal.h>
void (*signal(int signo, void *(func)(int)))(int);
```
  signo: 上面的信号名。
  func的值是: a) 常数SIG_IGN, b)SIG_DFL, c)当接到此信号后要调用的函数的地址。 SIG_IGN:则内核表示忽略此信号。(SIGKILL,SIGSTOP不能忽略。) SIG_DFL: 表示接到此信号时，使用系统默认动作。当指定函数地址时，我们称此为捕捉此信号。我们称此函数为信号处理程序(signal handler)或信号捕捉函数(signal-catching function).
  signal函数的原型说明此函数要求两个参数，返回一个函数指针，而该指针所指向的函数无返回值(void). 第一个参数signo是一个整型数，第二个参数是函数指针，它所指向的函数需要一个整型参数，无返回值。 用一般语言来描述也就是要向信号处理函数传递一个整型参数，而它却无返回值。当调用signal设置信号处理程序时，第二个参数指向该函数(也就是信号处理程序)的指针。signal的返回值则是指向以前的信号处理程序的指针。
  
  本节开头的signal原型太复杂了。如果使用下面的typedef，则可以使其简单一些:
```
typedef void Sigfunc(int);
Sigfunc *signal(int, Sigfunc *);
```
  我们已经将此typedef包括在我们的apue.h文件中。并随本章的函数一起使用。
  如果查看signal.h头文件，则可能会找到下列形式的说明:
```
#define SIG_ERR (void (*)()) -1;
#define SIG_DFL (void (*)())0;
#define SIG_IGN (void (*)())1;
```
  这三个常数可用于表示指向函数的指针，该函数要一个整型参数，而且无返回值。signal的第二个参数以及其返回值就可以用它们表示。这些常数所使用的三个值不一定要是-1, 0和1. 它们必须是三个值而绝不能是任一可说明函数的地址。大多数Unix系统使用上面所示的值。
  
```
include <signal.h>
#include "apue.h"

static void sig_usr(int); /** one handler for both signals **/

int
main(void)
{
    if(signal(SIGUSR1, sig_usr) == SIG_ERR)
        err_sys("signal error");
    if(signal(SIGUSR2, sig_usr) == SIG_ERR)
        err_sys("signal error");

    for(;;)
        pause();
}

static void
sig_usr(int signo)
{
    if(signo == SIGUSR1)
        printf("recevied SIGUSR1\n");

    else if(signo == SIGUSR2)
        printf("received SIGUSR2\n");
    else
        err_dump("received signal %d\n", signo);
    return;
}
```
  编译并运行如下:
```
bogon:signal apple$ ./signal &
[1] 1912
bogon:signal apple$ kill -USR1 1912
recevied SIGUSR1
bogon:signal apple$ kill -USR2 1912
received SIGUSR2
bogon:signal apple$ kill 1912
bogon:signal apple$ ls -la
total 48
drwxr-xr-x   5 apple  staff    170 12 11 16:35 .
drwxr-xr-x  13 apple  staff    442 12 11 15:34 ..
-rw-r--r--   1 apple  staff    261 12 11 15:34 makefile
-rwxr-xr-x   1 apple  staff  13684 12 11 16:35 signal
-rw-r--r--   1 apple  staff    544 12 11 16:35 signal.c
[1]+  Terminated: 15          ./signal
```
#### 10.3.1 程序启动
  当执行一个程序时，所有信号的状态都是系统默认或忽略。通常所有信号都被设置为系统默认动作，除非调用exec的进程忽略该信号。比较特殊的是，exec函数将原先设置为要捕捉的信号都更改为默认动作，其他信号的状态则不变(一个进程原先要捕捉的信号，当其执行一个新程序后，就自然地不能再捕捉了，因为信号捕捉函数的地址很可能再所执行的新程序文件中已无意义。)
  我们经常会碰到的一个具体例子是一个交互shell如何处理对后台进程的中断和退出信号。对于一个非作业控制shell,当在后台执行一个进程时，例如:`cc main.c &`
  shell自动将后台进程对中断和退出信号的处理方式设置为忽略。于是，当按中断键时就不会影响到后台进程。如果没有这样的处理，那么当按中断键时，他不但终止前台进程，也终止所有后台进程。
  很多捕捉这两个信号的交互程序具有下列形式的代码:
```
int sig_int(), sig_quit();
if(signal(SIGINT, SIG_IGN) != SIG_IGN)
  signal(SIGINT, sig_int);
if(signal(SIGQUIT, SIG_IGN) != SIG_IGN)
  signal(SIGQUIT, sig_quit());
```
  这样处理后，仅当SIGINT和SIGQUIT当前并不忽略，进程才捕捉它们。
  从signal的这两个调用中也可以看到这种函数的限制:不改变信号的处理方式就不能确定信号的当前处理方式。我们将在本章的稍后部分说明使用sigaction函数可以确定一个信号的处理方式，而无需改变它。
  
#### 10.3.2 进程创建
  当一个进程调用fork时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制了父进程存储图像，所以信号捕捉函数的地址在子进程中是有意义的。

### 10.4 不可信信号
  在早期的Unix版本中，信号是不可靠的。不可靠在这里指的是，信号可能会丢失---一个信号发生了，但进程却绝不知道这一点。那时，进程对信号的控制能力也很低，他能捕捉信号或忽略它，但有些很需要的功能他却不具备。例如，有时候用户希望通知内核阻塞一信号--不要忽略该信号，在其发生时记住它，然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备。
  
  早期版本中的一个问题是在进程每次处理信号时，随即将信号动作复置为默认值.以下是早期版本中关于如何处理中断信号的经典实例的代码:
```
int sig_int();  /** 自定义信号处理函数 **/

...
signal(SIGINT, sig_int); /** 确立信号处理函数 **/

sig_int()
{
  signal(SIGINT, sig_int); /** 重新确立下次发生信号的信号处理函数 **/
  
  ... /** 处理信号 **/
}
``` 
  由于早期的C语言版本不支持ANSI C的void类型数据，所以将信号处理程序说明为int类型。
  
  这种代码的一个问题是:在信号发生之后到信号处理程序中调用signal函数之间有一个时间窗口。在此段时间中，可能发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信号则是终止该进程。这种类型的程序在大多数情况下会正常工作，使得我们认为它们正确，而实际上却并不是如此。
  
  这些早期版本的另一个问题是:在进程不希望某种信号发生时，它不能关闭该信号。进程能做的就是忽略该信号。有时希望通知系统“阻塞下列信号发生，如果它们确实产生了，请记住它们。”这种问题的一个经典实例是下列程序段，它捕捉一个信号，然后设置一个表示该信号已经发生的标志:
```
int sig_int_flag; /** 当信号发生时设置非零 **/
main()
{
  int sig_int(); /** 自定义信号处理函数 **/
  
  signal(SIGINT, sig_int); /** 确定信号处理函数 **/
  
  while(sig_int_flag == 0)
    pause();    /** go to sleep, waiting for signal **/
  ...
}

sig_int()
{
  signal(SIGINT, sig_int); /** 重新确立下次信号发生时的信号处理函数 **/
  sig_int_flag = 1; /** 设置标志，让其在main主循环中检查 **/
}
```
  其中，进程调用pause()函数使自己睡眠，直到捕捉到一个信号。当信号被捕捉到后，信号处理程序将标志sig_int_flag设置为非0.在信号处理程序返回之后，内核将该进程唤醒，它检测到该标志位位非0，然后执行它所需做的。但是这里也有一个时间窗口，可能使操作错误。如果在测试sig_int_flag之后，调用pause之前发生信号，则此进程可能会一直睡眠(假定次信号不再次产生)。于是，这次发生的信号也就丢失了。还有另一个例子，某段代码并不正确，但是大多数时间却能正常工作。要查找并排除这种类型的问题很困难。
  
  
### 10.5 中断系统调用
  早期Unix系统的一个特性是: 如果在进程执行一个低速系统调用而阻塞期间捕捉到一个信号，则该调用就被中断不再继续执行。该系统调用返回出错，其errno设置位EINTR. 这样处理的理由是:因为一个信号发生了，进程捕捉到了它,这意味着已经发生了某种事情，所以是个好机会应该唤醒阻塞的系统调用。
```
  在这里我们必须区分系统调用和函数。当捕捉到某个信号时，被中断的是内核中执行的系统调用。
```
  为了支持这种特性，将系统调用分成两类:低速系统调用和其他系统调用。低速系统调用是可能会使进程永远阻塞的一类系统调用，它们包括:
  * 在读某些类型的文件时，如果数据并不存在则可能会使调用者永远阻塞(管道、中断设备以及网络设备)。
  * 在写某些类型的文件时，如果不能立即接受这些数据，则也可能会使调用者永远阻塞。
  * 打开文件，在某种条件发生之前也可能会使调用者阻塞(例如，打开终端设备，他要等待直到所有连接的调制解调器回答了电话)。
  * pause和wait
  * 某种ioctl操作。
  * 某些进程间通信函数。
  
  在这些低速系统调用中一个值得注意的例外是与磁盘I/O有关的系统调用。虽然读写一个磁盘文件能暂时阻塞调用者(在磁盘驱动程序将请求排入队列，然后在适当的时间执行请求期间)，但是除非发生硬件错误，I/O操作总会很快返回，并且使调用者不再处于阻塞状态。

  可以用中断系统调用这种方法来处理的一种情况是: 一个进程启动了读终端操作，而使用该终端设备的用户却离开该终端很长时间。在这种情况下进程可能处于阻塞状态几个消失甚至数天，除非系统停机，否则一直如此。
  
  与被中断的系统调用相关的问题是必须用显式方法处理出错返回。典型的代码序列(假定进行一个读操作，它被中断，我们希望启动它)可能如下列样式:
```
again:
  if((n = read(fd, buff, BUFFSIZE)) < 0) {
    if(errno == EINTR)
      goto again; /* just an interrupted system call */
    /* handler other errors */
  }
```
  为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引进了某些被中断的系统调用的自动再启动。自动再启动的系统调用包括:ioctl, read, readv, write, writev, wait和waitpid. 正如前所述，其中前面五个函数只有对低速设备进行操作时才会被信号中断。而wait和waitpid在捕捉到信号时总是被中断。某些应用程序并不希望这些函数被中断后再启动，因为这种自动再启动的处理方式也会带来问题，为此4.3BSD允许进程再每个信号个别处理的基础上不使用此功能。
  

### 10.6 可重入函数
  进程捕捉到信号并继续执行时，它首先执行该信号处理程序中的指令。如果从信号处理程序返回(例如没有调用exit或longjmp),则继续执行在捕捉到信号时进程正在执行的正常指令序列(这类似于硬件中国年断发生时所做的)。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。如果进程正在执行malloc,在其堆中国年分配另外的存储空间，而此时由于捕捉到信号插入该信号处理程序，其中又调用malloc, 这时会发生什么?又例如若进程正在执行getpwnam这种将其结果存放在静态存储单元中的函数，而插入执行的信号处理程序中又调用这样的函数，这时会发生什么呢?在malloc例子中，可能会堆进程造成破坏，因为malloc通常为它所分配的存储区中保持一个连接表，而插入该执行信号处理程序时，进程可能正在更改此连接表。在getpwnam例子中，正常返回给调用者的信息可能由返回至信号处理程序的信息覆盖。
  
  

### 10.7 SIGCLD语义
  SIGCLD和SIGCHLD这两个信号经常易于混淆。SIGCLD是系统V的一个信号名，其语义与名SIGCHLD的BSD信号不同。POSIX.1则采用BSD的SIGCHLD信号。
  BSD的SIGCHLD信号的语义与其他信号的语义相类似。子进程状态改变后产生此信号，父进程需要调用一个wait函数以检测发生了什么。
  
  由于历史的原因，系统V处理SIGCLD信号的方式不同于其他信号，如果用signal或sigset设置信号配置，则SVR4继续了这一具有问题色彩的传统。对于SIGCLD早期的处理方式是:
  1. 如果进程特地指定了堆该信号的配置为SIG_IGN,则调用进程的子进程将不产生僵死进程。注意，这与其默认动作SIG_DFL忽略不同。代之以，在子进程终止时，将其状态丢弃。如果调用进程最后调用一个wait函数，那么它将阻塞到所有子进程都终止，然后wait会返回-1,其errno则设置为ECHILD. 
  2. 如果将SIGCLD的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用SIGCLD处理程序。
  
  

### 10.8 可信信号术语及语义

### 10.9 kill和raise函数
  kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。
```
  raise是由ANSI C而非POSIX.1定义的。因为ANSI C并不涉及多进程，所以它不能定义如kill这样要有一个进程ID作为其参数的函数。

#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int signo);
int raise(int signo);
```
  kill的pid参数有四种不同的情况:
  1. pid > 0: 将信号发送给进程ID为pid的进程
  2. pid == 0: 将信号发送给其进程组ID等于发送进程的进程组ID,而且发送进程有许可权向其发送信号的的所有进程。
  3. pid < 0: 将信号发送给其进程组ID等于pid绝对值，而且发送进程有许可权向其发送信号的所有进程。如上所述，所有进程并不包括系统进程集中的进程。
  4. pid == -1: POSIX.1未定义此种情况。

### 10.10 alarm和pause函数
  使用alarm函数可以设置一个时间值(闹钟时间)，在将来的某个时刻该时间值会被超过。当所设置的时间值被超过后，产生SIGALRM信号。如果不忽略或不捕捉此信号，则其默认动作是终止该进程。
  
```
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```
  其中，参数seconds的值是秒数，经过了指定的seconds秒数后会产生信号SIGALRM. 要了解的是，经过了指定秒数后，信号由内核产生，由于进程调度的延迟，进程得到控制能够处理该信号还需要一段时间。
```
  早期的Unix版本曾提出警告，这种信号可能比预定值提前1秒发送。POSIX.1则不允许这样做。
```
  每个进程只能由一个闹钟时间。如果在调用alarm时，以前已为该进程设置过闹钟时间，而且它还没有超时，则闹钟时间的余留值作为本次alarm函数调用的值返回。以前登记的闹钟时间则被新值代换。
  
  如果有以前登记的尚未超过的闹钟时间，而且seconds值是0，则取消以前的闹钟时间，其余留值仍作为函数的返回值。
  
  虽然SIGALRM的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。如果此时进程要终止，则在终止之前它可以执行所需的清除操作。
  
  pause函数使调用进程挂起直至捕捉到一个信号。
```
#include <unistd.h>
int pause(void);
```
  只有执行了一个信号处理程序并从其返回时，pause才返回。在这种情况下，pause返回-1, errno设置为EINTR.
  
```
#include <signal.h>
#include <unistd.h>

static void
sig_alrm(int signo)
{
    return ; /** nothing to do, just return to wake up the pause **/
}

unsigned int 
sleep1(unsigned int nsecs)
{
    if(signal(SIGALRM, sig_alrm) == SIG_ERR)
        return nsecs;

    alarm(nsecs); /** start the timer **/
    pause(); /** next caught signal wakes us up **/

    return (alarm(0)); /** turn off timer, return unslept time **/
}
```
  程序中的sleep1函数看起来与将在10.19节中说明的sleep函数类似，但这种简化实现有如下列问题:
  1. 如果调用者已设置了闹钟，则它被sleep1函数中的第一次alarm调用擦去。
  <ul>
    <li>可用下列方法更正这一点:检查第一次调用alarm的返回值，如果其小于本次调用alarm的参数值，则只应等到该前次设置的闹钟时间超时。如果前次设置闹钟时间的超时时刻后于本次设置值，则在sleep1函数返回之前，再次设置闹钟时间，使其在预定时间再发生超时。</li>
  </ul>
  2. 该程序中修改了堆SIGALRM的配置。如果编写了一个函数供其他函数调用，则再该函数被调用时先要保存原配置，再函数返回前再恢复原配置。
  3. 在调用alarm和pause之间有一个静态条件。在一个繁忙的系统中，可能alarm在调用pause之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用pause后，如果没有捕捉到其他信号，则调用者将永远被挂起。
  
  sleep的早期实现与上面的程序类似，但更正了1，2问题。有两种方法可以更正问题3. 第一种方法是使用setjmp, 下面立即说明这种方法。另一种方法是使用sigprocmask和sigsuspend,10.19节将说明这种方法。



### 10.11 信号设置

### 10.12 sigprocmask函数

### 10.13 sigpending函数

### 10.14 sigaction函数

### 10.15 sigsetjmp和siglongjmp函数

### 10.16 sigsuspend函数

### 10.17 abort函数

### 10.18 system函数

### 10.19 sleep, nanosleep和clock_nanosleep函数

### 10.20 sigqueue函数

### 10.21 作业控制信号

### 10.22 信号名称及数字

### 10.23 总结
